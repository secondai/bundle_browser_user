{
  "_id": "5ac47afb65eb53001d560831",
  "nodeId": "5ac47ae265eb53001d56081e",
  "type": "react_component:0.0.1:local:98912hd89",
  "data": {
    "version": "14",
    "note": "/dev left side",
    "internalId": "ListNodeChainsComponent",
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              [ErrorRenderer]\n            </div>\n          )\n        }\n      }\n      \n      class ListComponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            nodes: [],\n            text: '',\n            pastable: false,\n            pasteText: ''\n          }\n        }\n        \n        componentDidMount(){\n          this.fetchNodeChains();\n          \n          \n          universe.EE.on('nodes-modified', this.fetchNodeChains);\n        \n        }\n        componentWillUnmount(){\n          universe.EE.removeListener('nodes-modified', this.fetchNodeChains);\n        }\n        \n        @autobind\n        fetchNodeChains(){\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                fetchingRemote: true\n              })\n              \n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main'\n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              \n              this.props.setState({\n                OwnerSecondExternalIdentityNode: ExternalIdentityNode\n              });\n      \n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      // must be root \n                                      if(inputNode.nodeId){\n                                        return false;\n                                      }\n                                      \n                                      if(inputNode.type.split(':')[0] != 'node_chain_info'){\n                                        return null;\n                                      }\n                                      \n                                      // if(inputNode.data.learn != 'browser_developer'){\n                                      //   return null;\n                                      // }\n                                      \n                                      // // strip childnodes\n                                      // // delete inputNode.nodes; \n                                      // // delete inputNode.parent;\n                                      // delete inputNode.data;\n              \n                                      return inputNode;\n                                      \n                                    })()`\n                                  }\n                                },\n                                \n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[0].data;\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                nodes: nodes,\n                fetchingRemote: false\n              })\n              \n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              this.setState({\n                fetchingRemote: false\n              })\n              \n            }\n            \n          });\n          \n        }\n      \n        @autobind\n        handleNewNode(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let type;\n            type = WINDOW.prompt('Type?','');\n            if(!type){\n              return false;\n            }\n            \n            type = type.trim();\n            \n            // todo: get and validate the type's schema. use schema for default data\n            \n            let newNode = {\n              // nodeId: node._id,\n              type: type,\n              data: null\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true});\n            \n            console.log('Saved Node', savedNode);\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n      \n            // window.location = '/node/' + savedNode._id;\n      \n          });\n      \n        }\n        \n        @autobind\n        async handleAddMany(){\n          // Adding a whole bunch, for testing \n          \n          if(!WINDOW.confirm('Save 20 nodes?')){\n            return false;\n          }\n          \n          for(let i in universe.lodash.range(0,20)){\n            console.log('Saving new node');\n            let nodeToSave = {\n              type: 'text_note:0.0.1:local:8290j2981',\n              data: {\n                text: 'test textnote ' + (new Date()).getTime()\n              },\n              active: true,\n              createdAt: (new Date()).getTime()\n            }\n            \n            await this.forceNewNode(nodeToSave, {skipExistingLearnedNodeId:true}, true);\n            \n          }\n          \n          try {\n            universe.EE.emit('nodes-modified', '');\n          }catch(err){\n            console.error(err);\n          }\n          \n        }\n        \n        @autobind\n        forceNewNode(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', nodeToSave);\n                \n            // return resolve({\n            //   saveNewNode: nodeToSave\n            // });\n            \n            \n            // Make request to save Node on remote \n            try {\n              \n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main'\n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                            dataForAction: {\n                              type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('NewNode response:', response);\n              \n              // get the new node \n              let savedNode = response.data.actionResponses[0];\n              \n              // console.log('Saved Node:', savedNode);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              return resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        handleClickNode(node){\n          this.props.setState({\n            nodeChainNode: node\n          })\n        }\n        \n        @autobind\n        handleInsertNodePaste(){\n          \n          return new Promise(async (resolve,reject)=>{\n      \n            let nodeText = this.state.pasteText; //WINDOW.prompt('Node JSON String','');\n            if(!nodeText){\n              return false;\n            }\n            \n            let node = JSON.parse(nodeText);\n            console.log('Node input:', node);\n            \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Save node ('+node.type+') and children for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n            \n            // iterate\n            // - save this one, then start saving down tree\n            let newNode = {\n              nodeId: null, \n              type: node.type,\n              data: node.data,\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true});\n            \n            console.log('Saved Node');\n          \n            const saveChildNodes = (nodeId, childNodes) => {\n              return new Promise(async (resolve, reject)=>{\n      \n                console.log('Saving children');\n                \n                for(let tmpNode of childNodes){\n                  let newChildNode = {\n                    nodeId,\n                    type: tmpNode.type,\n                    data: tmpNode.data,\n                  }\n                  let savedChildNode = await this.forceNewNode(newChildNode, {skipExistingLearnedNodeId: true});\n      \n                  if(tmpNode.nodes && tmpNode.nodes.length){\n      \n                    await saveChildNodes(savedChildNode.data._id, tmpNode.nodes);\n      \n                  }\n                }\n                resolve();\n              });\n            }\n      \n            await saveChildNodes(savedNode.data._id, node.nodes);\n            \n            console.log('Done Adding via Paste');\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n          });\n        }\n        \n        @autobind\n        handleNewId(){\n          let uuid = universe.uuidv4();\n          universe.copy(uuid);\n          console.log('Copied to clipboard');\n        }\n        \n        @autobind\n        async handleRegisterOnNodeChain(){\n          \n          // Request access to a NodeChain \n          // - TODO: request -> nodechain API -> nodechain's Second -> ... ? \n          \n          // currently just adding a NodeChain via identity \n          \n          \n          // Lookup the nodechain via identity \n          \n          let network = WINDOW.prompt('identity network','test');\n          if(!network){\n            return false;\n          }\n          \n          let username = WINDOW.prompt('username for identity?','test@teacher');\n          if(!username){\n            return false;\n          }\n          \n          \n          // validate that nodechain exists \n          // - lookup identity \n          // - lookup nodechain, make \"info\" request \n          let nodeInfo = await universe.getNodeForUsernameKey(username, network, 'nodechain');\n          \n          console.log('nodeInfo:', nodeInfo);\n          \n          // Store nodechain info in remote Second \n          let newNode = {\n            type: 'node_chain_info:0.0.1:local:3298h92',\n            data: {\n              apiAddress: nodeInfo.data.apiAddress,\n              network,\n              username,\n              pubKey: nodeInfo.data.pubKey,\n            },\n          }\n    \n          console.log('newNode:', newNode);\n    \n          let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true});\n          \n          \n          \n        }\n        \n        @autobind\n        async handleCreateNodeChain(){\n          \n          // Create my own NodeChain \n          \n          \n          // let apiAddress = WINDOW.prompt('apiAddress?','https://api.getsecond.com');\n          let apiAddress = WINDOW.prompt('apiAddress?','https://api.getasecond.com');\n          if(!apiAddress){\n            return false;\n          }\n          \n          let network = WINDOW.prompt('identity network','test');\n          if(!network){\n            return false;\n          }\n          \n          let username = WINDOW.prompt('username for identity?','test@teacher');\n          if(!username){\n            return false;\n          }\n          \n          // Create a new keypair for managing the nodechain \n          let publishKey = new universe.rsa({b:256});\n          let publishPrivateKey = publishKey.exportKey('private');\n          let publishPublicKey = publishKey.exportKey('public');\n          \n          console.log('NodeChain pubKey:', publishPublicKey);\n          let data = `{\n            \"operationName\":null,\n            \"variables\":{\n              \"pubKey\":${JSON.stringify(publishPublicKey)}\n            },\n            \"query\":\"mutation ($pubKey: String) {  chain { create ( record: {pubKey: $pubKey}){    recordId    __typename  }}}\"\n          }`;\n          console.log('Data:', data);\n          data = JSON.parse(data);\n          \n          // Make request to apiAddress to create new NodeChain \n          // - TODO: permissions/auth in order to create a new nodechain \n          console.log('Saving to API:', data);\n          \n          let savedToApi = await universe.fetch(`${apiAddress}/graphql`,{\n            // mode: 'no-cors' \n            method: 'post',\n            body: JSON.stringify(data),\n            headers: {\n              'Content-Type': 'application/json'\n            }\n          })\n          .then(response=>{\n            console.log('Response:', response);\n            return response.json();\n          })\n    \n          console.log('saved to api:', savedToApi);\n          \n          // saved via API ok?\n          if(!savedToApi.data.chain.create.recordId){\n            WINDOW.alert('Failed creating new chain via API');\n            return false;\n          }\n          \n          \n          \n          // Store nodechain info in remote Second \n          let newNode = {\n            type: 'node_chain_info:0.0.1:local:3298h92',\n            data: {\n              apiAddress,\n              network,\n              username,\n              privateKey: publishPrivateKey,\n              pubKey: publishPublicKey,\n            },\n          }\n    \n          console.log('newNode:', newNode);\n    \n          let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true});\n          \n          \n          // Register identity information through Remote Second (manageData) \n          let manageDataInfo = {\n            type: 'manage_data_info:0.0.1:local:392j3f',\n            data: {\n              network: 'test', //network,\n              username: 'dev@second', //username,\n              field: 'nodechain',\n              nodeValue: {\n                type: 'node_chain_info:0.0.1:local:3298h92',\n                data: {\n                  apiAddress, //: 'https://api.getasecond.com',\n                  pubKey: publishPublicKey, //: `-----BEGIN PUBLIC KEY-----\n// MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCBNnFC2kVynYCdh441NxFqB2TV\n// KTYZPPZgMfSdqrdCOAFq3g0W2TmvSzS2qY43DV80tpzzENi4bnOkOUFVl9Xi553C\n// ++hdnqg+pAGbT9P3Cr7r6CN1ZNBPx8JXnyWNfxzNhi+rCma1EpZaoRHbVxTX170V\n// W2qyoyZI8qG9rsqB7QIDAQAB\n// -----END PUBLIC KEY-----` \n                }\n              }\n            }\n          };\n        \n          try {\n            \n            let ExternalIdentityNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  type: 'external_identity:0.0.1:local:8982f982j92',\n                  data: {\n                    commonName: 'main'\n                  }\n                }\n              }\n            });\n            let ExternalIdentityNode = ExternalIdentityNodes[0];\n            \n            let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'send',\n                options: {\n                  ExternalIdentityNode,\n                  RequestNode: {\n                    type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                    data: {\n                      actions: [\n                        {\n                          matchActionType: 'identity_manage_data:0.0.1:local:3829hf298h928h3f',\n                          dataForAction: {\n                            type: 'identity_manage_data:0.0.1:local:3829hf298h928h3f',\n                            data: manageDataInfo\n                          }\n                        }\n                      ]\n                      \n                    }\n                  }\n                }\n              }\n            });\n            \n            console.log('NewChain response:', response);\n            \n            // get the new node \n            let manageDataResult = response.data.actionResponses[0];\n            \n            // result is a node, with data of node type:boolean\n            if(!manageDataResult.data.data){\n              WINDOW.alert('Failed registering NodeChain on identity');\n              return false;\n            }\n            \n            \n            \n            universe.EE.emit('nodes-modified', '');\n            \n            return resolve(savedNode);\n            \n            // this.setState({\n            //   saving: false\n            // })\n            \n          } catch(err){\n            console.error('Failed newchain nodes', err);\n            \n            // alert('Failed');\n            \n            // this.setState({\n            //   saving: false\n            // })\n            \n          }\n          \n          \n          \n        }\n        \n        @autobind\n        renderChains(nodes, parentInFilter){\n          \n          let filter = this.state.text;\n          \n          // nodes = universe.lodash.sortBy(nodes, 'updatedAt');\n          \n          return (\n            <div className=\"\">\n              {\n                nodes.map(node=>{\n                          \n                  // include this node if it, or of of it's children, matches\n                  // - highlight if a match \n                \n                  const nodeMatchFunc = (node) => {\n                    let nodeMatch;\n                    if(node.type && node.type.includes(filter)){\n                      nodeMatch = true;\n                    }\n                    if(node.data && JSON.stringify(node.data).includes(filter)){\n                      nodeMatch = true;\n                    }\n                    // type (t:)\n                    if(filter.includes('t:') && node.type){\n                      let tmpFilter = filter.split('t:')[1];\n                      if(node.type && node.type.includes(tmpFilter)){\n                        nodeMatch = true;\n                      }\n                    }\n                    // data (d:) \n                    if(filter.includes('d:')){\n                      let tmpFilter = filter.split('d:')[1];\n                      if(node.data && JSON.stringify(node.data).includes(tmpFilter)){\n                        nodeMatch = true;\n                      }\n                    }\n                    \n                    return nodeMatch;\n                    \n                  }\n                  \n                  const childMatchFunc = (nodes) => {\n                    for(let tmpNode of nodes){\n                      if(nodeMatchFunc(tmpNode)){\n                        return true;\n                      }\n                      if(childMatchFunc(tmpNode.nodes)){\n                        return true;\n                      }\n                    }\n                    return false;\n                  }\n                  \n                  let hasFilter = filter.length ? true:false;\n                  let nodeMatch;\n                  let childMatch;\n                  if(hasFilter){\n                    \n                    nodeMatch = nodeMatchFunc(node);\n                    childMatch = childMatchFunc(node.nodes || []);\n                    \n                    // check children \n                    // - lots of recursion here, probably should memoize \n                    \n                    \n                    // // filter by \"text\" if set \n                    // nodes = nodes.filter(node=>{\n                    //   return true;\n                    // })\n                  }\n                  \n                  if(hasFilter && !nodeMatch && !childMatch && !parentInFilter){\n                    return undefined; // skip\n                  }\n                  \n                  let tooltip = null;\n                  // return a different tooltip depending on the type\n                  let nodeTypeFirst = node.type ? node.type.split(':')[0]:null;\n                  try {\n                    switch(nodeTypeFirst){\n                      // case 'react_component':\n                      //   tooltip = node.data.internalId;\n                      //   break;\n                        \n                      default:\n                        tooltip = node.data.apiAddress;\n                        break;\n                    }\n                  }catch(err){\n                  }\n                  \n                  return (\n                    <div key={node._id}>\n                      <div onClick={e=>this.handleClickNode(node)} style={{cursor:'pointer', color: nodeMatch ? 'blue':'inherit'}}>\n                    \n                          <div className=\"hover-item tooltip-holder\">\n                            <div className=\"tooltip-trigger\">\n                              {\n                                node.data.privateKey ? <span className=\"icon\"><i className=\"fa fa-arrow-right\"></i></span>:''\n                              }\n                              {\n                                (this.props.state.editingNode && this.props.state.editingNode._id == node._id) ?\n                                  <strong>\n                                    {node.data.username || 'missing username'}\n                                  </strong>\n                                  :\n                                  (node.data.username || 'missing username')\n                              }\n                            </div>\n                            {\n                              !tooltip ? '':\n                              <div className=\"tooltip\">\n                                {tooltip}\n                              </div>\n                            }\n                          </div>\n                          \n                      </div>\n                      \n                    </div>\n                  )\n                })\n              }\n            </div>\n          )\n        }\n        \n        render(){\n          \n          let nodes = this.state.nodes;\n          \n          // load actions from remote!\n          // - want to have some default actions that are easy to call/trigger \n          // - simple way of calling a Capability? \n          let actions = [];\n          \n          return (\n            <div className=\"\">\n              \n              {\n                !this.state.pastable ? '':\n                <div>\n                  <textarea className=\"textarea\" value={this.state.pasteText} onChange={e=>this.setState({pasteText:e.target.value})} />\n                  <button className=\"button is-primary\" onClick={this.handleInsertNodePaste}>Save</button>\n                  <button className=\"button pull-right\" onClick={e=>this.setState({pastable:false})}>cancel</button>\n                </div>\n              }\n              \n              <strong>\n                NodeChains\n                \n                &nbsp;\n                \n                <button className={\"button is-small \" + (this.state.fetchingRemote ? 'is-loading':'')} onClick={this.fetchNodeChains}>\n                  <span className=\"icon is-small\">\n                    <i className=\"fa fa-refresh\"></i>\n                  </span>\n                </button>\n                \n                <div className=\"dropdown is-hoverable is-right pull-right\">\n                  <div className=\"dropdown-trigger\">\n                    <button className=\"button is-small\">\n                      <span className=\"icon is-small\">\n                        <i className=\"fa fa-angle-down\"></i>\n                      </span>\n                    </button>\n                  </div>\n                  <div className=\"dropdown-menu\">\n                    <div className=\"dropdown-content\">\n                    \n                      <a className=\"dropdown-item\" onClick={this.handleRegisterOnNodeChain}>\n                        Join Existing NodeChain \n                      </a>\n                      \n                      <a className=\"dropdown-item\" onClick={this.handleCreateNodeChain}>\n                        Create New NodeChain\n                      </a>\n                      \n                    </div>\n                  </div>\n                </div>\n                \n              </strong>\n              \n              \n              <div>\n                <input className=\"input\" value={this.state.text} onChange={e=>this.setState({text:e.target.value})} placeholder=\"Filter on data attributes\" />\n              </div>\n              \n              {this.renderChains(nodes)}\n              \n            </div>\n          )\n        }\n      }\n      \n      ListComponent = universe.ReactGlobalState(ListComponent);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: ListComponent\n      });\n      \n    }catch(err){\n      resolve({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
    "key": "b40b2246-020f-46bb-b991-6f55285469af",
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----",
    "nodeChainNode": {
      "type": "node_chain_info:0.0.1:local:3298h92",
      "data": {
        "apiAddress": "https://api.getasecond.com",
        "network": "test",
        "username": "dev@second",
        "pubKey": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCBNnFC2kVynYCdh441NxFqB2TV\nKTYZPPZgMfSdqrdCOAFq3g0W2TmvSzS2qY43DV80tpzzENi4bnOkOUFVl9Xi553C\n++hdnqg+pAGbT9P3Cr7r6CN1ZNBPx8JXnyWNfxzNhi+rCma1EpZaoRHbVxTX170V\nW2qyoyZI8qG9rsqB7QIDAQAB\n-----END PUBLIC KEY-----"
      }
    }
  },
  "active": true,
  "createdAt": 1522825979423,
  "updatedAt": null
}