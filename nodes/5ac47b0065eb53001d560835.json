{
  "_id": "5ac47b0065eb53001d560835",
  "nodeId": "5ac47ae265eb53001d56081e",
  "type": "react_component:0.0.1:local:98912hd89",
  "data": {
    "version": "1",
    "key": "65b3eaca-7868-4ac6-9710-5a641b2ea3c3",
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      const Link = universe.ReactRouterDomLink;\n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        render(){\n          return (\n            <div>\n              ErrorLoading\n            </div>\n          )\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            appNode: null, // app selected in store \n            storeApps: [], // apps in the store (\"app_base\" nodes)\n          }\n        }\n        \n        componentDidMount(){\n          \n          // storeNode must exist! \n          // - redirect if not\n          if(!this.props.state.storeNode){\n            console.log('Missing this.props.state.storeNode');\n            this.props.history.push('/');\n            return;\n          }\n          \n          console.log('Mounted MainExternalAppStoreComponent');\n          \n          this.fetchAll();\n          universe.EE.on('nodes-modified', this.fetchAll);\n          \n        }\n        componentWillUnmount(){\n          universe.EE.removeListener('nodes-modified', this.fetchAll);\n        }\n        \n        @autobind\n        async countInstallNodes(){\n          \n          let appNode = this.state.appNode;\n          \n          let installTotal = 1;\n          const countNodes = (childNodes) => {\n            return new Promise(async (resolve, reject)=>{\n    \n              console.log('Saving children');\n              \n              for(let tmpNode of childNodes){\n                installTotal++;\n                if(tmpNode.nodes && tmpNode.nodes.length){\n                  await countNodes(tmpNode.nodes);\n                }\n              }\n              resolve();\n            });\n          }\n          \n          await countNodes(appNode.nodes);\n          \n          this.setState({\n            installTotal\n          });\n          \n        }\n        \n        @autobind\n        async fetchAll(){\n          \n          await this.fetchStoreApps();\n          \n        }\n        \n        @autobind\n        fetchStoreApps(props){\n          // fetch data by passing the request through the cloud/server Second \n          \n          props = props || this.props;\n          \n          console.log('fetchStoreApps.New Props', props);\n          \n          let {\n            OwnerSecondExternalIdentityNode,\n             // friend's ExternalIdentityNode on cloud Second\n          } = props.state;\n          \n          let ExternalIdentityNode = this.props.state.storeNode;\n          \n          if(!OwnerSecondExternalIdentityNode || !ExternalIdentityNode){\n            console.log('Missing OwnerSecondExternalIdentityNode or ExternalIdentityNode (of App Store)', OwnerSecondExternalIdentityNode, ExternalIdentityNode);\n            return false;\n          }\n          \n          console.log('Fetching inside remote:', ExternalIdentityNode);\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              // this is the query sent to the remote-remote! \n              let searchRequestNode = {\n                type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                data: {\n                  matchFunctionNode: {\n                    type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                    data: {\n                      code: `(()=>{\n                        let inputNode = INPUT.data.inputNode;\n                        if(inputNode.nodeId){\n                          return false;\n                        }\n                        \n                        if(inputNode.type.split(':')[0] != 'app_base'){\n                          return false;\n                        }\n                        \n                        // // return first level of children (should have \"platform_nodes\") \n                        // inputNode.nodes = (inputNode.nodes || []).map(childNode=>{\n                        //   delete childNode.nodes;\n                        //   return childNode;\n                        // });\n                        \n                        return inputNode;\n                        \n                      })()`\n                    }\n                  },\n                }\n              }\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          \n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: OwnerSecondExternalIdentityNode.data.token\n                            }\n                          },\n                          \n                          {\n                            matchActionType: 'search_remote_datasource:0.0.1:local:3249sfj2389fh289',\n                            dataForAction: {\n                              type: 'standard_remote_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                internalId: ExternalIdentityNode._id,\n                                // publicKey: ExternalIdentityNode.data.publicKey,\n                                RequestNode: searchRequestNode\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              console.log('FullExternalResponse', response);\n              \n              let externalResponse = response.data.actionResponses[1];\n              \n              let remoteRemoteResponse = externalResponse.data.actionResponses;\n              \n              let nodes = remoteRemoteResponse[1].data;\n              \n              // console.log('NODES in response:', externalResponse);\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                storeApps: nodes\n              })\n            } catch(err){\n              console.error('Failed getting local nodes',err);\n            }\n            \n          });\n          \n          \n        }\n        \n        @autobind\n        handleViewApp(node){\n          this.setState({\n            appNode: node\n          },this.countInstallNodes);\n          \n        }\n        \n        @autobind\n        async handleInstall(appNode){\n          // install an app by inserting Nodes into your Second \n          // - needs to be faster than updating individually? (can easily break!) \n          // - after launching, creates an app_data directory \n          \n          // moves entire \"app_base\" over \n          // - launches app's platform:browser nodes \n          \n          console.log('AppNode:', appNode);\n          \n          if(!WINDOW.confirm('Install App?')){\n            return false;\n          }\n          \n          \n          this.setState({\n            installing: true,\n            installCurrent: 0\n          });\n          \n          // TODO: update anything in app_base? \n          // - development, hidden from friends, etc. \n          \n          // iterate\n          // - save this one, then start saving down tree\n          let newNode = {\n            nodeId: null,\n            type: appNode.type,\n            data: JSON.parse(JSON.stringify(appNode.data))\n          }\n          \n          console.log('newNode:', newNode);\n    \n          let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true}, true);\n          \n          console.log('Saved Node');\n          \n          let installCurrent = 1;\n          const saveChildNodes = (nodeId, childNodes) => {\n            return new Promise(async (resolve, reject)=>{\n    \n              console.log('Saving children');\n              \n              for(let tmpNode of childNodes){\n                let newChildNode = {\n                  nodeId,\n                  type: tmpNode.type,\n                  data: tmpNode.data,\n                }\n                let savedChildNode = await this.forceNewNode(newChildNode, {skipExistingLearnedNodeId: true}, true);\n                \n                  installCurrent++;      \n                  this.setState({\n                    installCurrent\n                  });\n                  \n    \n                if(tmpNode.nodes && tmpNode.nodes.length){\n    \n                  await saveChildNodes(savedChildNode.data._id, tmpNode.nodes);\n    \n                }\n              }\n              resolve();\n            });\n          }\n    \n          await saveChildNodes(savedNode.data._id, appNode.nodes);\n          \n          console.log('Done installing');\n          \n          \n          this.setState({\n            installing: false\n          });\n    \n          \n          // Launch immediately \n          if(WINDOW.prompt('Launch App? (y/n)', 'y') == 'y'){\n            console.log('Launching app');\n            this.handleLaunchApp(appNode); // pulls out platform_nodes:browser\n          }\n          \n          \n          \n          \n        }\n        \n        @autobind\n        handleLaunchApp(appNode){\n          \n          // Get name, platform nodes \n          let name = appNode.data.name;\n          let platformNode = appNode.nodes.find(node=>{\n            return (\n              node.type.split(':')[0] == 'platform_nodes'\n              &&\n              node.data.platform == 'browser'\n            )\n          });\n          \n          if(!platformNode || !platformNode.nodes || !platformNode.nodes.length){\n            return WINDOW.alert('Missing platform_nodes for platform:browser');\n          }\n          \n          // remove nodeId from root nodes \n          let platformNodes = platformNode.nodes.map(node=>{\n            delete node.nodeId;\n            return node;\n          });\n          \n          \n          // launch app!\n          // - exists App Store, updates localStorage through Environment/Platform \n          universe.handleCreateNewSecondFromNodes(name, platformNodes);\n          \n          \n        }\n        \n        @autobind\n        forceNewNode(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', nodeToSave);\n                \n            // return resolve({\n            //   saveNewNode: nodeToSave\n            // });\n            \n            \n            // Make request to save Node on remote \n            try {\n              \n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main' // should keep using for browser development! \n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                            dataForAction: {\n                              type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('NewNode response:', response);\n              \n              // get the new node \n              let savedNode = response.data.actionResponses[0];\n              \n              // console.log('Saved Node:', savedNode);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              return resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n          })\n        }\n        \n        \n        @autobind\n        renderAppNode(node){\n          // \"app_base\" types only \n          return (\n            <div key={node._id} onClick={e=>this.handleViewApp(node)} style={{cursor:'pointer'}}>\n              <strong>\n                {node.data.name}\n              </strong>\n            </div>\n          )\n        }\n        \n        \n        render(){\n          \n          let appNode = this.state.appNode;\n          \n          let metadataData = this.props.state.storeNodeMetadata ? this.props.state.storeNodeMetadata.data :{} ;\n          \n          return (\n            <div className=\"flex-main\">\n              <div className=\"flex-left\" style={{padding:'4px'}}>\n                \n                <h2 className=\"title is-5\">\n                  Store: {metadataData.username}\n                </h2>\n                \n                <div>\n                  {\n                    this.state.storeApps.map(this.renderAppNode)\n                  }\n                </div>\n                \n              </div>\n              <div className=\"flex-middle\">\n                \n                \n                {\n                  !appNode ? '':\n                  <div>\n                    <h3 className=\"title is-3\">\n                      {appNode.data.name}\n                    </h3>\n                    <h3 className=\"subtitle is-5\">\n                      {appNode.data.appId} : {appNode.data.release} : {appNode.data.version}\n                    </h3>\n                    \n                    <br />\n                    \n                    <div className=\"field has-addons\">\n                      <div className=\"control\">\n                        <button className={\"button\"} onClick={e=>this.handleInstall(appNode)}>\n                          Install\n                        </button>\n                      </div>\n                      {\n                        !this.state.installing ? '':\n                        <div className=\"control\">\n                          <button className=\"button is-loading\">\n                            &nbsp;\n                          </button>\n                        </div>\n                      }\n                      {\n                        this.state.installing ? \n                          <div className=\"control\">\n                            <button className=\"button\">\n                              {this.state.installCurrent}/{this.state.installTotal}\n                            </button>\n                          </div>\n                        :\n                          <div className=\"control\">\n                            <button className=\"button\">\n                              {this.state.installTotal}\n                            </button>\n                          </div>\n                      }\n                    </div>\n                    \n                  </div>\n                }\n                \n              </div>\n              \n            </div>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      mycomponent = universe.ReactRouterDomWithRouter(mycomponent);\n      \n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
    "internalId": "MainExternalAppStoreComponent",
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----"
  },
  "active": true,
  "createdAt": 1522825984900,
  "updatedAt": null
}