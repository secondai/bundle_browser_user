{
  "_id": "5aa85061500a8d002c3b754b",
  "nodeId": "5a8e6c8e974a57006dd9a5bc",
  "type": "react_component:0.0.1:local:98912hd89",
  "data": {
    "version": "11",
    "internalId": "LocalCodeNodesComponent",
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              [ErrorRenderer]\n            </div>\n          )\n        }\n      }\n      \n      class ListComponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            status: 'local', // local, remote, connectedTo \n            nodes: [],\n            text: '',\n            pastable: false,\n            pasteText: ''\n          }\n        }\n        \n        componentDidMount(){\n          this.fetchAll();\n          \n          \n          universe.EE.on('nodes-modified', this.fetchAll);\n        \n        }\n        componentWillUnmount(){\n          universe.EE.removeListener('nodes-modified', this.fetchAll);\n        }\n        \n        @autobind\n        handleChangeStatus(status){\n          this.setState({\n            status\n          }, this.fetchAll);\n        }\n        \n        @autobind\n        async fetchAll(){\n          \n          // Get local code nodes \n          let LocalCodeNodes; // = await this.fetchLocalNodes();\n          \n          // Get latest for local nodes from NodeChain\n          switch(this.state.status){\n            case 'local':\n              LocalCodeNodes = await this.fetchLocalNodes();\n              break;\n            case 'remote':\n              LocalCodeNodes = await this.fetchRemoteNodes();\n              break;\n            case 'thru':\n              // TODO\n            default:\n              break;\n              \n          }\n          \n          await this.fetchUpdatedNodes(LocalCodeNodes);\n          \n        }\n        \n        @autobind\n        fetchLocalNodes(){\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n            \n            \n            // Fetch all of my local Code/React nodes \n            // - get the key (unique) for each) \n            // - ask Teacher Second for code matches for code items (and react components) \n            let CodeNodes = await universe.searchMemory({\n              filter: {\n                filterNodes: tmpNodes=>{\n                  return new Promise((resolve, reject)=>{\n                    tmpNodes = tmpNodes.map(tmpNode=>{\n                      let types = [\n                        'code',\n                        'react_component',\n                        'preparse_code',\n                        'action_code'\n                      ]\n                      if(types.indexOf(tmpNode.type.split(':')[0]) === -1){\n                        return false;\n                      }\n                      delete tmpNode.parent;\n                      delete tmpNode.nodes;\n                      return tmpNode;\n                    })\n                    resolve(universe.lodash.compact(tmpNodes));\n                  });\n                },\n              }\n            });\n            \n            \n            // let componentNode = await universe.runInVM(result[0],{});\n            this.setState({\n              nodes: CodeNodes\n            })\n            \n            return resolve(CodeNodes);\n            \n            \n          });\n          \n        }\n        \n        @autobind\n        fetchRemoteNodes(){\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                fetching: true\n              })\n              \n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main'\n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              \n              this.props.setState({\n                OwnerSecondExternalIdentityNode: ExternalIdentityNode\n              });\n      \n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      let types = [\n                                        'code',\n                                        'react_component',\n                                        'preparse_code',\n                                        'action_code'\n                                      ]\n                                      if(types.indexOf(inputNode.type.split(':')[0]) === -1){\n                                        return false;\n                                      }\n                                      \n                                      delete inputNode.parent;\n                                      \n                                      return inputNode;\n                                      \n                                    })()`\n                                  }\n                                },\n                                // expected/allowed schemas for return \n                                // outputSchemas: [\n                                //   'query_result:0.0.1:local:32490usfj23o23f',\n                                //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n                                // ]\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[0].data;\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                nodes: nodes,\n                fetching: false\n              })\n              \n              this.fetchUpdatedNodes(nodes);\n              \n            } catch(err){\n              console.error('Failed getting remote nodes');\n              WINDOW.alert('Failed getting remote nodes');\n              \n              this.setState({\n                fetching: false\n              })\n              \n            }\n            \n          });\n          \n        }\n        \n        @autobind\n        fetchUpdatedNodes(CodeNodes){\n          return new Promise(async (resolve,reject)=>{\n            \n            // Search chains for latest nodes (must have author/ref)  \n            \n            this.setState({\n              fetching: true\n            })\n            \n            \n            // searching ALL chains that have ANY matches \n            // - exposes to each API all my code nodes, which isn't ideal \n            //   - TODO: make more selective for querying; some code nodes just need to query themselves \n            \n            \n            let searches = [];\n            let chainsToSearch = [];\n            CodeNodes.forEach(node=>{\n              if(!node.data.key){\n                // skipping, no author!\n                node.__status = 'missing_local_ref' // update node by reference\n                return;\n              }\n              node.__status = 'searching';\n              let obj = {};\n              obj.ref = node.data.key;\n              if(node.data.author){\n                obj.author = node.data.author;\n              }\n              searches.push(obj);\n              chainsToSearch.push(node.data.nodeChainNode);\n            })\n            \n            this.setState({\n              nodes: CodeNodes\n            })\n            \n            // get unique chains \n            chainsToSearch = universe.lodash.uniqBy(chainsToSearch, (nodeChainNode)=>{\n              if(!nodeChainNode){\n                // skips \n                return false;\n              }\n              \n              return [nodeChainNode.data.network, nodeChainNode.data.username].join('');\n              \n            });\n            \n            chainsToSearch = universe.lodash.compact(chainsToSearch);\n            \n            // Search all chains at once \n            let searchChainPromises = [];\n            chainsToSearch.map(chain=>{\n              searchChainPromises.push(new Promise(async (resolve,reject)=>{\n                let chainNodes = await universe.findOnNodeChain({\n                  method: 'latestForEach',\n                  searches,\n                  chainPubKey: chain.data.pubKey,\n                  apiAddress: chain.data.apiAddress\n                });\n                resolve({\n                  nodeChainNode: chain,\n                  chainNodes\n                });\n              }));\n            });\n            \n            let chainResults = await Promise.all(searchChainPromises);\n            \n            console.log('ChainResults', chainResults);\n            \n            // console.log('chainNodes', chainNodes);\n            \n            \n            // Iterate over CodeNodes and add the latest chainNode that matches \n            // - update status \n            CodeNodes.forEach(node=>{\n              if(!node.data.key){\n                // already skipped\n                console.log('skipped');\n                return;\n              }\n              // find matches from chain \n              // - currently: just shows __status for matching chain \n              // - TODO: check all chains \n              let recent;\n              chainResults.forEach(chainResult=>{\n                if(!node.data.nodeChainNode){\n                  // missing nodeChainNode \n                  return false;\n                }\n                if(chainResult.nodeChainNode.data.username == node.data.nodeChainNode.data.username &&\n                   chainResult.nodeChainNode.data.network == node.data.nodeChainNode.data.network\n                ){\n                  chainResult.chainNodes.forEach(cn=>{\n                        \n                    if(node.data.author && \n                      node.data.key == cn.ref && \n                      node.data.author == cn.author\n                      ){\n                      recent = cn;\n                      return true;\n                    } else if(\n                      node.data.key == cn.ref) {\n                      recent = cn;\n                      return true;\n                    }\n                    return false;\n                  })\n                }\n              });\n              if(!recent){\n                console.log('not_found_on_chain');\n                node.__status = 'not_found_on_chain';\n                return;\n              }\n              \n              // TODO: have a __status for a new author? \n              \n              if(node.data.version && node.data.version.toString() == recent.version.toString()){\n                node.__status = 'same_version';\n              } else {\n                // new version available!\n                node.__status = 'diff_version';\n                node.ChainNode = recent;\n              }\n              \n            })\n            \n            // let componentNode = await universe.runInVM(result[0],{});\n            this.setState({\n              nodes: CodeNodes,\n              fetching: false\n            })\n            \n            return resolve(CodeNodes);\n            \n            \n          });\n          \n        }\n        \n        @autobind\n        handleClickNode(node){\n          console.log('Node',node);\n        }\n        \n        @autobind\n        async updateNewCode(){\n          \n          this.setState({\n            fetching: true\n          })\n          \n          let CodeNodes = this.state.nodes;\n          \n          // update local nodes \n          // - data.[note, code, version]\n          try {\n            for(let node of CodeNodes){\n              if(node.__status == 'diff_version'){\n                node.data.code = node.ChainNode.data.code;\n                node.data.note = node.ChainNode.data.note;\n                node.data.version = node.ChainNode.data.version;\n                \n                console.log('Updating Node:', this.state.status, node);\n                \n                let updatedNode;\n                \n                // Update according to status \n                switch(this.state.status){\n                  case 'local':\n                    updatedNode = await universe.updateNode(node); \n                    break;\n                  case 'remote':\n                    // console.log('UPDATE REMOTE:', node);\n                    updatedNode = await this.makeSaveRequest(node);\n                    break;\n                  case 'thru':\n                    // TODO\n                  default:\n                    break;\n                    \n                }\n                \n              }\n            }\n          }catch(err){\n            console.error(err);\n          }\n          \n          \n          // Get latest for local nodes from NodeChain\n          switch(this.state.status){\n            case 'local':\n              WINDOW.alert('Updated. Might need to reload page for visual changes to take effect');\n              break;\n            case 'remote':\n              WINDOW.alert('Remote Second Updated');\n              break;\n            case 'thru':\n              // TODO\n            default:\n              break;\n              \n          }\n          \n          this.fetchAll();\n          \n          // setTimeout(()=>{\n          //   WINDOW.location.reload();\n          // },1000);\n          \n        }\n        \n        @autobind\n        makeSaveRequest(tmpNodeToSave){\n          return new Promise(async (resolve, reject) => {\n            \n            let nodeToSave = {\n              _id: tmpNodeToSave._id,\n              data: tmpNodeToSave.data\n            }\n            \n            // Make request to save Node on remote \n            try {\n              \n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main'\n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'update_node:0.0.1:local:392821982y3',\n                            dataForAction: {\n                              type: 'node:0.0.1:local:123445',\n                              data: nodeToSave\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('Update response:', response);\n              \n              return resolve({\n                type: 'node:...',\n                data: response.data.actionResponses[0]\n              });\n              \n            } catch(err){\n              console.error('Failed updating remote code node');\n              \n              WINDOW.alert('Failed');\n              \n              return reject();\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        renderStatus(node){\n          \n          let opacity = 1;\n          let color = '';\n          let icon = '';\n          \n          switch(node.__status){\n            case 'missing_local_ref':\n              opacity = 0.5;\n              color = 'has-text-danger';\n              icon = 'fa-exclamation-triangle';\n              break;\n              \n            case 'searching':\n              icon = 'fa-spinner';\n              break;\n              \n            case 'not_found_on_chain':\n              color = 'has-text-warning';\n              icon = 'fa-exclamation-triangle';\n              break;\n              \n            case 'same_version':\n              icon = 'fa-angle-double-right';\n              break;\n              \n            case 'diff_version':\n              color = 'has-text-success'\n              icon = 'fa-plus-square';\n              break;\n              \n            default:\n              icon = '';\n              break;\n          }\n          \n          return (\n  \n            <div className=\"hover-item tooltip-holder\">\n              <div className=\"tooltip-trigger\">\n                <span className={\"icon \" + color} style={{opacity}}>\n                  <i className={\"fa \" + icon}></i>\n                </span>\n              </div>\n              <div className=\"tooltip\">\n                {node.__status}\n              </div>\n            </div>\n            \n          )\n        }\n        \n        @autobind\n        renderNodes(nodes, parentInFilter){\n          \n          let filter = this.state.text;\n          \n          nodes = universe.lodash.sortBy(nodes, 'updatedAt');\n          // console.log('Nodes',nodes);\n          \n          return (\n            <div className=\"\">\n              {\n                nodes.map(node=>{\n                          \n                  // include this node if it, or of of it's children, matches\n                  // - highlight if a match \n                \n                  const nodeMatchFunc = (node) => {\n                    let nodeMatch;\n                    if(node.type && node.type.includes(filter)){\n                      nodeMatch = true;\n                    }\n                    if(node.data && JSON.stringify(node.data).includes(filter)){\n                      nodeMatch = true;\n                    }\n                    // type (t:)\n                    if(filter.includes('t:') && node.type){\n                      let tmpFilter = filter.split('t:')[1];\n                      if(node.type && node.type.includes(tmpFilter)){\n                        nodeMatch = true;\n                      }\n                    }\n                    // data (d:) \n                    if(filter.includes('d:')){\n                      let tmpFilter = filter.split('d:')[1];\n                      if(node.data && JSON.stringify(node.data).includes(tmpFilter)){\n                        nodeMatch = true;\n                      }\n                    }\n                    \n                    return nodeMatch;\n                    \n                  }\n                  \n                  const childMatchFunc = (nodes) => {\n                    for(let tmpNode of nodes){\n                      if(nodeMatchFunc(tmpNode)){\n                        return true;\n                      }\n                      if(childMatchFunc(tmpNode.nodes)){\n                        return true;\n                      }\n                    }\n                    return false;\n                  }\n                  \n                  let hasFilter = filter.length ? true:false;\n                  let nodeMatch;\n                  let childMatch;\n                  if(hasFilter){\n                    \n                    nodeMatch = nodeMatchFunc(node);\n                    childMatch = childMatchFunc(node.nodes || []);\n                    \n                    // check children \n                    // - lots of recursion here, probably should memoize \n                    \n                    \n                    // // filter by \"text\" if set \n                    // nodes = nodes.filter(node=>{\n                    //   return true;\n                    // })\n                  }\n                  \n                  if(hasFilter && !nodeMatch && !childMatch && !parentInFilter){\n                    return undefined; // skip\n                  }\n                  \n                  let tooltip = null;\n                  // return a different tooltip depending on the type\n                  let nodeTypeFirst = node.type ? node.type.split(':')[0]:null;\n                  try {\n                    switch(nodeTypeFirst){\n                      case 'react_component':\n                        tooltip = node.data.internalId;\n                        break;\n                        \n                      case 'parent_of_nodes_to_learn':\n                        tooltip = node.data.learn;\n                        break;\n                        \n                      case 'text_tag':\n                        tooltip = node.data.text;\n                        break;\n                        \n                      case 'capability':\n                        tooltip = node.data.key;\n                        break;\n                        \n                      case 'code':\n                        tooltip = node.data.note;\n                        break;\n                        \n                      case 'external_identity':\n                        tooltip = node.data.commonName || '(no commonName)';\n                        break;\n                        \n                      case 'external_identity_connect_method':\n                        tooltip = node.data.connection;\n                        break;\n                        \n                      case 'folder':\n                        tooltip = node.data.key;\n                        break;\n                        \n                      case 'node_repo_on_github':\n                        tooltip = node.data.repo;\n                        break;\n                        \n                      default:\n                        break;\n                    }\n                  }catch(err){\n                  }\n                  \n                  return (\n                    <table className=\"\" key={node._id}>\n                      <tbody>\n                        <tr>\n                          <td style={{width:'28px'}}>\n                            {this.renderStatus(node)}\n                          </td>\n                          <td>\n                            <div onClick={e=>this.handleClickNode(node)} style={{cursor:'pointer', color: nodeMatch ? 'blue':'inherit'}}>\n                          \n                                <div className=\"hover-item tooltip-holder\">\n                                  <div className=\"tooltip-trigger\">\n                                    {\n                                      (this.props.state.editingNode && this.props.state.editingNode._id == node._id) ?\n                                        <strong>\n                                          {node.type}\n                                        </strong>\n                                        :\n                                        node.type\n                                    }\n                                  </div>\n                                  {\n                                    !tooltip ? '':\n                                    <div className=\"tooltip\">\n                                      {tooltip}\n                                    </div>\n                                  }\n                                </div>\n                                \n                            </div>\n                          </td>\n                        </tr>\n                      </tbody>\n                    </table>\n                  )\n                })\n              }\n            </div>\n          )\n        }\n        \n        render(){\n          \n          let nodes = this.state.nodes;\n          \n          // load actions from remote!\n          // - want to have some default actions that are easy to call/trigger \n          // - simple way of calling a Capability? \n          let actions = [];\n          \n          return (\n            <div className=\"\">\n              \n              {\n                !this.state.pastable ? '':\n                <div>\n                  <textarea className=\"textarea\" value={this.state.pasteText} onChange={e=>this.setState({pasteText:e.target.value})} />\n                  <button className=\"button is-primary\" onClick={this.handleInsertNodePaste}>Save</button>\n                  <button className=\"button pull-right\" onClick={e=>this.setState({pastable:false})}>cancel</button>\n                </div>\n              }\n              \n              <strong>\n                \n                {\n                  this.state.status != 'local' ?'':\n                  'Local Code Nodes'\n                }\n                {\n                  this.state.status != 'remote' ? '':\n                  'Remote Code Nodes'\n                }\n                {\n                  this.state.status != 'thru' ? '':\n                  'Remote Connected Code Nodes'\n                }\n                \n                &nbsp;\n                \n                <button className={\"button is-small \" + (this.state.fetching ? 'is-loading':'')} onClick={this.fetchAll}>\n                  <span className=\"icon is-small\">\n                    <i className=\"fa fa-refresh\"></i>\n                  </span>\n                </button>\n                \n                <div className=\"dropdown is-hoverable is-right pull-right\">\n                  <div className=\"dropdown-trigger\">\n                    <button className=\"button is-small\">\n                      <span className=\"icon is-small\">\n                        <i className=\"fa fa-angle-down\"></i>\n                      </span>\n                    </button>\n                  </div>\n                  <div className=\"dropdown-menu\">\n                    <div className=\"dropdown-content\">\n                    \n                      <a className=\"dropdown-item\" onClick={e=>this.handleChangeStatus('local')}>\n                        {\n                          this.state.status != 'local' ? \n                          <span className=\"icon\">\n                            <i className=\"fa fa-square\"></i>\n                          </span>\n                          :\n                          <span className=\"icon\">\n                            <i className=\"fa fa-check-square\"></i>\n                          </span>\n                        } Local Code Nodes\n                      </a>\n                      \n                      <a className=\"dropdown-item\" onClick={e=>this.handleChangeStatus('remote')}>\n                        {\n                          this.state.status != 'remote' ? \n                          <span className=\"icon\">\n                            <i className=\"fa fa-square\"></i>\n                          </span>\n                          :\n                          <span className=\"icon\">\n                            <i className=\"fa fa-check-square\"></i>\n                          </span>\n                        } Remote Code Nodes\n                      </a>\n                      \n                      <div className=\"dropdown-divider\"></div>\n                      \n                      <a className=\"dropdown-item\" onClick={this.updateNewCode}>\n                        Update all [+] (new version) \n                      </a>\n                      \n                    </div>\n                  </div>\n                </div>\n                \n              </strong>\n              \n              \n              <div>\n                <input className=\"input\" value={this.state.text} onChange={e=>this.setState({text:e.target.value})} placeholder=\"Filter on type/data\" />\n              </div>\n              \n              {this.renderNodes(nodes)}\n              \n            </div>\n          )\n        }\n      }\n      \n      ListComponent = universe.ReactGlobalState(ListComponent);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: ListComponent\n      });\n      \n    }catch(err){\n      resolve({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
    "key": "68ddfc23-3f94-4a01-a905-7f9c48286d60",
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----"
  },
  "active": true,
  "createdAt": 1520980065298,
  "updatedAt": 1522039974999
}