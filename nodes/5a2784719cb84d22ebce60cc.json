{
  "_id": "5a2784719cb84d22ebce60cc",
  "nodeId": "5a2784709cb84d22ebce60bb",
  "type": "code:0.0.1:local:32498h32f2",
  "data": {
    "key": "a9c55c9a-327f-46ba-938c-2237fba25eae",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // ONLY FOR: user_default\n      \n      // handles an incoming Node from the Universe \n      // - handles the majority of request types:\n      //   - first request (only seeded) \n      //   - web request \n      //   - internal heartbeat \n      //   - internal \"wakeup\" \n      \n      // This accepts a Node that defines the type of data it is, and how we should start handling the request \n      // - the \"if I know nothing, learn things\" command is in here as well \n      \n      switch(INPUT.type){\n        \n        case 'incoming_first:0.1.1:local:78882h37':\n        \n          // Determine if environment if browser, cloud, app\n          // - determine if we ask for what to download? \n          \n          // This is called only once, after \"learnBasics\" populated default Nodes \n          // - basic capabilities are included/available  \n          \n          // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // - uses a constant value (token) from the remote Second! \n          let newIdentityNode = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'createLocal',\n              options: {}\n            }\n          });\n          \n          \n          // Find remote Second \n          // - hash of keywords -> wallet address -> encrypted via last keyword? \n          // - want a publicKey and a URL returned \n          //   - a whole IdentityNode should be returned? \n          // - return: \n          //   - external_identity:0.0.1:local:8982f982j92\n          //   - external_identity_connect_method:0.0.1:local:382989239hsdfmn\n          \n          let remoteValue;\n          try {\n            remoteValue = WINDOW.prompt('Remote Second','test21 test21');\n          }catch(err){\n            console.error('Not in Tab');\n            remoteValue = 'test test';\n          }\n          \n          console.log('Words to use for ExternalIdentity:', remoteValue);\n          \n          // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // - uses a constant value (token) from the remote Second! \n          let addressNode = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'getAddressForWords',\n              options: {\n                words: remoteValue\n              }\n            }\n          });\n          \n          let address = addressNode.data;\n          \n          // fetch that wallet address, get the first transaction \n          // - first transaction contains IPFS link \n          // - IPFS contains Nodes (without _ids!) \n          let foundExternalIdentityNode = await universe.getIdentityForAddress(address);\n          \n          console.log('Got foundExternalIdentityNode',foundExternalIdentityNode);\n          \n          // Save ExternalIdentityNode locally! \n          let ExternalIdentityNode = await universe.loadAndRunCapability('Identity',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'saveExternal',\n              options: {\n                ExternalIdentityNode: foundExternalIdentityNode // should contain a connection method! \n              }\n            }\n          });\n          \n          // Update local node commonName (for easy lookup) \n          ExternalIdentityNode.data.commonName = 'main';\n          let updatedExternal = await universe.updateNode(ExternalIdentityNode);\n          \n          \n          console.log('Saved new ExternalIdentityNode', ExternalIdentityNode);\n          \n          // await universe.newNode(ExternalIdentityNode);\n          \n          // return resolve({\n          //   ExternalIdentityNode,\n          //   error: true,\n          //   remoteValue,\n          //   address\n          // })\n          \n          \n          let internalUserPassphrase;\n          try {\n            internalUserPassphrase = WINDOW.prompt('Internal User Passphrase','testuserpassphrase');\n          }catch(err){\n            console.error('Not in Tab');\n            internalUserPassphrase = 'testuserpassphrase';\n          }\n          \n          \n          \n          // Identify and Upgrade connection as an InternalUser (using passphrase) \n          // - this uses the newly-created ExternalIdentityNode user \n          // - also upgrades our local data.token \n          \n          try {\n            \n          // Authenticate with External Second \n          // - make authenticated requests to a Second (necessary for Learning?) \n          //   - should have ALL requests authenticated \n          // universe.setupExternalSecond();\n            \n            // Initiating Identify ...again\n            let authExternalIdentityNode2 = await universe.loadAndRunCapability('IdentifyInitiate',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'start',\n                options: {\n                  externalIdentityPublicKey: ExternalIdentityNode.data.publicKey,\n                  // authToken: 'eeaac41bdb1b717d137a53779db97457:07e0fbe19e72c3ff7e329fc293bcf5b51d780c4c3c60f80403b2fea8f30d0daa5e4891dbdd6c57d9844622078a681853f31202d0632f0ee95031c9369a60708ddb6220e248e3c2ec6b3bb3c00eb2425aea922351d7128ef333ea5fe6a8ad139c1978759e29b057db1e655f2fe7c8962e' // \"learn\" \n                }\n              }\n            });\n            \n            console.log('Finished IdentifyInitiate2. Starting IdentifyActAsInternalUser');\n          \n            let actAsNode = await universe.loadAndRunCapability('IdentifyActAsInternalUser',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'start',\n                options: {\n                  externalIdentityPublicKey: ExternalIdentityNode.data.publicKey,\n                  internalUserPassphrase\n                }\n              }\n            });\n            console.log('Finished Upgrading local identity with ActAs. actAsNode Response', actAsNode);\n            \n            \n            // Test new user (am I really ActAs?) \\\n            let e2Nodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  nodeId: null,\n                  type: 'external_identity:0.0.1:local:8982f982j92',\n                  data: {\n                    publicKey: ExternalIdentityNode.data.publicKey\n                  }\n                }\n              }\n            });\n            let e2node = e2Nodes[0];\n            \n            console.log('e2node:', e2node);\n            \n            let e2response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'send',\n                options: {\n                  ExternalIdentityNode: e2node,\n                  RequestNode: {\n                    type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                    data: {\n                      actions: [\n                              \n                        {\n                          matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                          dataForAction: {\n                            type: 'string:...',\n                            data: e2node.data.token\n                          }\n                        },\n                        \n                        // {\n                        //   matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                        //   dataForAction: {\n                        //     type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                        //     data: {}\n                        //   }\n                        // }\n                      ]\n                      \n                    }\n                  }\n                }\n              }\n            });\n            \n            console.log('e2response',e2response);\n            \n          }catch(err){\n            console.error('Failed actAsNode upgrade',err);\n          }\n          \n          \n          \n          return resolve({\n            externalResponse: true,\n            // response,\n            codeResultNode,\n            // localResult\n          })\n          \n          \n          // let IdentityNode = null;\n          // let identities = await universe.searchMemory({\n          //   filter: {\n          //     sqlFilter: {\n          //       type: 'remote_datasource:0.0.1:local:298f3h92hf9s8dhf23f'\n          //     },\n          //     // function for returning data from the Node, after filtering a bit \n          //     // - includes both the Node, and Nodes with nodeId (pointers) \n          //     filterNodes: tmpNodes=>{\n          //       // this runs isolated, outside of the above context? (not sure) \n          //       return new Promise((resolve, reject)=>{\n          //         resolve(tmpNodes);\n          //       });\n          //     },\n          //   }\n          // });\n          \n          \n          break;\n          \n        case 'incoming_wakeup:0.0.1:local:8923yf89h9h':\n          // Wakeup \n          // - handles loading capabilities that will be used later \n          //   - loads all Capabilities (require things in?), adds them to GlobalCache \n          //   - on subsequent requests, universe.capabilities() should work. \n          \n          break;\n          \n        case 'incoming_heartbeat:0.0.1:local:23849u492348c7n9':\n          // Heartbeat (ever 1 second or so is expected) \n          break;\n          \n        case 'incoming_web_request:0.0.1:local:29832398h4723':\n          // request via HTTP post method (expressjs server expected) \n          // - headers and body are included\n          //   - body is JSON (expected to be!) \n          break;\n          \n        case 'incoming_web_request_blob:0.0.1:local:293h98h92f3':\n          // todo: handle incoming Blob data \n          break;\n          \n        case 'incoming_web_request_websocket:0.0.1:local:293h98h92f3':\n          // todo: handle incoming websocket request \n          // - could also be on browser? \n          break;\n          \n        case 'incoming_browser_request:0.0.1:local:829329329f832':\n          // incoming request (if in a browser) \n          // - expecting INPUT.type.data is a node! \n          // - might be actions, or something else \n            \n            \n          let nodes = await universe.searchMemory({\n            filter: {\n              filterNodes: tmpNodes=>{\n                // this runs isolated, outside of the above context? (not sure) \n                return new Promise((resolve, reject)=>{\n                  tmpNodes = tmpNodes.filter(tmpNode=>{\n                    // see if has a ChildNode matching a type \n                    let foundMatcherChild = universe.lodash.find(tmpNode.nodes || [],tmpChildNode=>{\n                      return tmpChildNode.type == 'incoming_query_type_matcher:0.0.1:local:3242rx23rd3';\n                    })\n                    // 'run_action:0.0.1:local:2398y294c23'\n                    if(!foundMatcherChild){\n                      return false;\n                    }\n                    \n                    return foundMatcherChild.data.typeMatch == INPUT.data.type;\n                  });\n                  resolve(tmpNodes);\n                });\n              },\n            }\n          });\n          \n          if(nodes && nodes.length){\n            // found Node to run for action! \n  \n            let codeNode = universe.lodash.find(nodes[0].nodes,{type:'code:0.0.1:local:32498h32f2'});\n            \n            // run in vm, and pass in the inputSchema Node! \n            // - of the action! (expecting/requiring it to be a Node w/ code....how to verify that? logic vs data?) \n            let actionResult;\n            try {\n              actionResult = await universe.runNodeCodeInVM({\n                codeNode,\n                dataNode: INPUT\n              });\n              \n              // ,{\n              //   codeNode, // includes type/schemaName and data \n              //   dataNode: INPUT, // should be another Node that can be used by the action! \n              //   timeout: 15 * 1000\n              // });\n            }catch(err){\n              return resolve('FAILED code from incoming_browser_request');\n            }\n            \n            // validate actionResult!\n            // - todo\n            \n            return resolve(actionResult);\n            // { \n            //   txt: 'Response:', \n            //   nodeTypes: nodes.map(n=>n.type),\n            //   actionResult\n            // }); // + result);\n            \n          } else {\n            // no Node found for handling action :( \n              \n            return resolve({ \n              error: 'No Nodes for action (incoming_browser_request)',\n              INPUT\n            }); // + result);\n          }\n          \n          \n          // switch(INPUT.data.type){\n            \n          //   case 'ping:0.0.1:local:239fh298fh239h23':\n          //     return resolve({\n          //       ping: 'pong'\n          //     });\n            \n          //   case 'browser_startup:0.0.1:local:8831167ssd':\n          //     // setting up initial component \n          //     let result = await universe.searchMemory({\n          //       filter: {\n          //         sqlFilter: {\n          //           type: 'react_component:0.0.1:local:98912hd89',\n          //           data: {\n          //             internalId: 'MainComponent'\n          //           }\n          //         }\n          //       }\n          //     });\n          //     let componentNode = await universe.runInVM(result[0],{});\n              \n          //     return resolve(componentNode);\n            \n          //   default:\n          //     break;\n          // }\n          \n          break;\n          \n          \n        default:\n          break;\n      }\n\n      return resolve({\n        type: 'err:..',\n        data: {\n          msg: 'Missing valid input type'\n        }\n      });\n      \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  },
  "active": true,
  "createdAt": 1512539249438,
  "updatedAt": 1513150330358
}