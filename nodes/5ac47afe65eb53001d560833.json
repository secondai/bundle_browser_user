{
  "_id": "5ac47afe65eb53001d560833",
  "nodeId": "5ac47ae265eb53001d56081e",
  "type": "react_component:0.0.1:local:98912hd89",
  "data": {
    "version": "1",
    "key": "faa2a143-d785-4e89-a271-f54f75ae333b",
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      const Link = universe.ReactRouterDomLink;\n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        render(){\n          return (\n            <div>\n              ErrorLoading\n            </div>\n          )\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            myAppNode: null, // for when an app is selected (start new, view instances, data, etc.) \n            myApps: [], // apps in my Cloud Second \n            remoteStores: [], // remote identities (every Second is an App Store) \n            runningInstances: [] // apps in localstorage (browser apps only) \n          }\n        }\n        \n        componentDidMount(){\n          \n          console.log('Mounted MainMyAppStoreComponent');\n          \n          this.fetchAll();\n          universe.EE.on('nodes-modified', this.fetchAll);\n          \n        }\n        componentWillUnmount(){\n          universe.EE.removeListener('nodes-modified', this.fetchAll);\n        }\n        \n        @autobind\n        async fetchAll(){\n          \n          await this.fetchMyApps();\n          await this.fetchAppStores();\n          \n        }\n        \n        @autobind\n        async fetchMyApps(){\n          // fetch apps from my Second \n          // - \"app_base\" on root \n          \n          try {\n            \n            this.setState({\n              fetchingRemote: true\n            })\n            \n            let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'send',\n                options: {\n                  ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                  RequestNode: {\n                    type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                    data: {\n                      actions: [\n                        {\n                          matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                          dataForAction: {\n                            type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                            data: {\n                              matchFunctionNode: {\n                                // query here!\n                                // action_pointer:0.0.1:local:238972ncr\n                                type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                data: {\n                                  code: `(()=>{\n                                    // Action \n                                    // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                    \n                                    let inputNode = INPUT.data.inputNode;\n                                    \n                                    if(inputNode.nodeId){\n                                      return false;\n                                    }\n                                    \n                                    if(inputNode.type.split(':')[0] != 'app_base'){\n                                      return false;\n                                    }\n                                    \n                                    // includes child nodes \n                                    // - unnecessary here! \n                                    // - should fetch when loading actual App (after clicked) \n                                    // - or just needs \"platform_nodes\" children, not whole apps? \n                                    \n                                    \n                                    return inputNode; \n                                    \n                                  })()`\n                                }\n                              },\n                            }\n                          }\n                        }\n                      ]\n                      \n                    }\n                  }\n                }\n              }\n            });\n            \n            // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n            let nodes = response.data.actionResponses[0].data;\n            \n            // let componentNode = await universe.runInVM(result[0],{});\n            this.setState({\n              myApps: nodes,\n              fetchingRemote: false\n            })\n            \n            \n          } catch(err){\n            console.error('Failed getting myApps nodes');\n            \n            this.setState({\n              fetchingRemote: false\n            })\n            \n          }\n          \n          \n        }\n        \n        @autobind\n        async fetchAppStores(){\n          // fetch external identities\n          // - TODO: have an \"is app store\" options \n          \n          // TODO: don't include \"myself\" as identity \n          \n          try {\n            \n            this.setState({\n              fetchingRemote: true\n            })\n            \n            let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'send',\n                options: {\n                  ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                  RequestNode: {\n                    type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                    data: {\n                      actions: [\n                        {\n                          matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                          dataForAction: {\n                            type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                            data: {\n                              matchFunctionNode: {\n                                // query here!\n                                // action_pointer:0.0.1:local:238972ncr\n                                type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                data: {\n                                  code: `(()=>{\n                                    // Action \n                                    // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                    \n                                    let inputNode = INPUT.data.inputNode;\n                                    \n                                    if(inputNode.nodeId){\n                                      return false;\n                                    }\n                                    \n                                    if(inputNode.type.split(':')[0] != 'external_identity'){\n                                      return false;\n                                    }\n                                    \n                                    if(!inputNode.nodes.filter(child=>{\n                                      return (\n                                        child.type.split(':')[0] == 'external_metadata'\n                                        &&\n                                        child.data.hasOwnProperty('username') // must exist\n                                      );\n                                    }).length){\n                                      return false;\n                                    }\n                                    \n                                    return inputNode; \n                                    \n                                  })()`\n                                }\n                              },\n                            }\n                          }\n                        }\n                      ]\n                      \n                    }\n                  }\n                }\n              }\n            });\n            \n            // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n            let nodes = response.data.actionResponses[0].data;\n            \n            // let componentNode = await universe.runInVM(result[0],{});\n            this.setState({\n              remoteStores: nodes,\n              fetchingRemote: false\n            })\n            \n            \n          } catch(err){\n            console.error('Failed getting myApps nodes');\n            \n            this.setState({\n              fetchingRemote: false\n            })\n            \n          }\n          \n          \n        }\n        \n        @autobind\n        async handleAddAppStore(){\n          // add a new identity (each Second has data that is an app store) \n          // - currently adding WITHOUT authorizing with remote Second? \n          //   - should authorize before adding \n          \n          // Request access to a NodeChain \n          // - TODO: request -> nodechain API -> nodechain's Second -> ... ? \n          \n          // currently just adding a NodeChain via identity \n          \n          \n          // Lookup the nodechain via identity \n          \n          let network = WINDOW.prompt('identity network','test');\n          if(!network){\n            return false;\n          }\n          \n          let username = WINDOW.prompt('username for identity?','teacher');\n          if(!username){\n            return false;\n          }\n          \n          \n          // validate that nodechain exists \n          // - lookup identity \n          // - lookup nodechain, make \"info\" request \n          let Friend_ExternalIdentityNode = await universe.getNodeForUsernameKey(username, network, 'second');\n          \n          \n          // let Friend_ExternalIdentityNode = await universe.getSecondForUsername(username,opts);\n          \n          // // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // // - uses a constant value (token) from the remote Second! \n          // let addressNode = await universe.loadAndRunCapability('Identity',{},{\n          //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n          //   data: {\n          //     action: 'getAddressForWords',\n          //     options: {\n          //       words\n          //     }\n          //   }\n          // });\n          \n          // let address = addressNode.data;\n          \n          // console.log('Address:', address);\n          \n          // let Friend_ExternalIdentityNode = await universe.getIdentityForAddress(address);\n          \n          console.log('MySecond:', this.props.state.OwnerSecondExternalIdentityNode);\n          console.log('FriendSecond', Friend_ExternalIdentityNode);\n          \n          \n          // Make TalkToSecond request to Identify MySecond with remote \n          let connectionResponse = await universe.loadAndRunCapability('TalkToSecond',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'send',\n              options: {\n                ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                RequestNode: {\n                  type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                  data: {\n                    actions: [\n                      {\n                        matchActionType: 'identify_challenge_initiate:0.0.1:local:8239hf28hf283h',\n                        dataForAction: {\n                          type: 'challenge_init_remote:0.0.1:...',\n                          data: {\n                            ExternalIdentityNode: Friend_ExternalIdentityNode\n                          }\n                        }\n                      }\n                    ]\n                    \n                  }\n                }\n              }\n            }\n          });\n          \n          console.log('Friend Connection Response:', connectionResponse);\n          \n          let responseNode = connectionResponse.data.actionResponses[0];\n          \n          // if added, include an internal \"basic data\" node \n          // - identity, groups, tags \n          if(responseNode.data.result){\n            \n            let newExternalMetadata = {\n              nodeId: responseNode.data.node._id,\n              type: 'external_metadata:dslfjdklj',\n              data: {\n                username,\n                groups: ['friends'],\n                tags: [],\n                network\n              }\n            }\n            console.log('newExternalMetadata', newExternalMetadata);\n            let savedNode = await this.forceNewNode(newExternalMetadata, {skipExistingLearnedNodeId: true});\n            \n          } else {\n            WINDOW.alert('Failed Adding');\n          }\n          \n          \n          \n        }\n        \n        @autobind\n        forceNewNode(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', nodeToSave);\n                \n            // return resolve({\n            //   saveNewNode: nodeToSave\n            // });\n            \n            \n            // Make request to save Node on remote \n            try {\n              \n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main' // should keep using for browser development! \n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                            dataForAction: {\n                              type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('NewNode response:', response);\n              \n              // get the new node \n              let savedNode = response.data.actionResponses[0];\n              \n              // console.log('Saved Node:', savedNode);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              return resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        handleViewApp(node){\n          this.setState({\n            myAppNode: node\n          });\n        }\n        \n        @autobind\n        handleViewExternalStore(node){\n          \n          // Loads remote Second from ExternalIdentityNode \n          console.log('handleViewExternalStore');\n          let storeNodeMetadata = node.nodes.find(n=>{return (n.type.split(':')[0] == 'external_metadata')});\n          console.log('storeNodeMetadata', storeNodeMetadata);\n          \n          this.props.setState({\n            storeNode: node,\n            storeNodeMetadata\n          },()=>{\n            console.log('updated state, updating history');\n            this.props.history.push('/appstore'); // TODO: include identity in URL\n          });\n        }\n        \n        @autobind\n        handleLaunchApp(appNode){\n          \n          // Get name, platform nodes \n          let name = appNode.data.name;\n          let platformNode = appNode.nodes.find(node=>{\n            return (\n              node.type.split(':')[0] == 'platform_nodes'\n              &&\n              node.data.platform == 'browser'\n            )\n          });\n          \n          if(!platformNode || !platformNode.nodes || !platformNode.nodes.length){\n            return WINDOW.alert('Missing platform_nodes for platform:browser');\n          }\n          \n          // remove nodeId from root nodes \n          let platformNodes = platformNode.nodes.map(node=>{\n            delete node.nodeId;\n            return node;\n          });\n          \n          \n          // launch app!\n          // - exists App Store, updates localStorage through Environment/Platform \n          universe.handleCreateNewSecondFromNodes(name, platformNodes);\n          \n          \n        }\n        \n        @autobind\n        handleEditApp(appNode){\n          \n          // Launch the editor view with the root as this app \n          // - NOT siblings! \n          \n          this.props.setState({\n            appNodeRoot: appNode\n          },()=>{\n            console.log('updated state, updating history');\n            this.props.history.push('/editapp'); // TODO: include identity in URL\n          });\n          \n        }\n        \n        \n        @autobind\n        renderMyAppNode(node){\n          // \"app_base\" types only \n          return (\n            <div key={node._id} onClick={e=>this.handleViewApp(node)} style={{cursor:'pointer'}}>\n              <strong>\n                {node.data.name}\n              </strong>\n            </div>\n          )\n        }\n        \n        \n        @autobind\n        renderExternalStoreNode(node){\n          // should have an \"app_store\" node child \n          // - we can easily add one to any existing external_identity \n          let metadataNode = node.nodes.find(n=>{return n.type.split(':')[0] == 'external_metadata'});\n          return (\n            <div key={node._id} onClick={e=>this.handleViewExternalStore(node)} style={{cursor:'pointer'}}>\n              <strong>\n                {metadataNode.data.username}\n              </strong>\n            </div>\n          )\n        }\n        \n        render(){\n          \n          let {\n            myAppNode\n          } = this.state;\n          \n          return (\n            <div className=\"flex-main\">\n              <div className=\"flex-left\" style={{padding:'4px'}}>\n                \n                <h2 className=\"title is-5\">\n                  My Apps\n                </h2>\n                \n                <div>\n                  {\n                    this.state.myApps.map(this.renderMyAppNode)\n                  }\n                </div>\n                \n              </div>\n              <div className=\"flex-middle\">\n                \n                {\n                  !myAppNode ? '':\n                  <div>\n                    <h3 className=\"title is-3\">\n                      {myAppNode.data.name}\n                    </h3>\n                    <h3 className=\"subtitle is-5\">\n                      {myAppNode.data.appId} : {myAppNode.data.release} : {myAppNode.data.version}\n                    </h3>\n                    \n                    <br />\n                    \n                    <div>\n                    \n                      <button className=\"button\" onClick={e=>this.handleLaunchApp(myAppNode)}>\n                        Launch New\n                      </button>\n                      \n                      &nbsp;\n                      \n                      <button className=\"button\" onClick={e=>this.handleEditApp(myAppNode)}>\n                        Modify\n                      </button>\n                      \n                    </div>\n                    \n                  </div>\n                }\n                \n              </div>\n              <div className=\"flex-right\" style={{padding:'4px'}}>\n                \n                <h2 className=\"title is-5\">\n                  App Stores\n                </h2>\n                \n                <div>\n                  {\n                    this.state.remoteStores.map(this.renderExternalStoreNode)\n                  }\n                </div>\n                \n                <br />\n                \n                <div>\n                  <button className=\"button\" onClick={this.handleAddAppStore}>\n                    Add App Store\n                  </button>\n                </div>\n                \n                \n              </div>\n              \n            </div>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      mycomponent = universe.ReactRouterDomWithRouter(mycomponent);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
    "internalId": "MainMyAppStoreComponent",
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----"
  },
  "active": true,
  "createdAt": 1522825982231,
  "updatedAt": 1522917057148
}