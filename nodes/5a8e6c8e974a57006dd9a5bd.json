{
  "_id": "5a8e6c8e974a57006dd9a5bd",
  "nodeId": "5a8e6c8e974a57006dd9a5bc",
  "type": "react_component:0.0.1:local:98912hd89",
  "data": {
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----",
    "version": "3",
    "internalId": "SetupComponent",
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      const Router = universe.ReactRouterDomRouter;\n      const Route = universe.ReactRouterDomRoute;\n      const Switch = universe.ReactRouterDomSwitch;\n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        render(){\n          return (\n            <div>\n              ErrorLoading\n            </div>\n          )\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            findingHash: false,\n            confirming: false,\n            confirmed: false,\n            connecting: false,\n            fetchingIpfs: false,\n            ipfsData: null,\n            developerComponent: null,\n            horizonPossible: [\n              {\n                name: 'PubNet',\n                address: 'https://horizon.stellar.org'\n              },\n              {\n                name: 'TestNet',\n                address: 'https://horizon-testnet.stellar.org'\n              }\n            ],\n            horizonServerAddress: 1,\n            username: universe.env.REACT_APP_LOGIN_USERNAME,\n            actas: universe.env.REACT_APP_LOGIN_PASSPHRASE,\n            errors: []\n          }\n        }\n        \n        componentDidMount(){\n          \n        }\n        \n        @autobind\n        updateUsername(e){\n          this.setState({\n            username: e.target.value.toLowerCase()\n          })\n        }\n        \n        @autobind\n        confirmIdentity(){\n          \n          return new Promise(async(resolve,reject)=>{\n              \n            console.log('Confirming Identity');\n            \n            let username = this.state.username;\n            \n            this.setState({\n              findingHash: true,\n              errors: []\n            });\n            \n            universe.StellarSdk.Network.useTestNetwork();\n            let stellarServer = new universe.StellarSdk.Server(this.state.horizonPossible[this.state.horizonServerAddress].address);\n            \n            console.log('stellarServer', stellarServer);\n            \n            let pkTargetSeed = universe.crypto.createHash('sha256').update(username).digest(); //returns a buffer\n            console.log('pkTargetSeed', pkTargetSeed);\n            \n            var pairTarget = universe.StellarSdk.Keypair.fromRawEd25519Seed(pkTargetSeed);\n            \n            console.log('pairTarget', pairTarget);\n            \n            let targetAccount;\n            try {\n              targetAccount = await stellarServer.loadAccount(pairTarget.publicKey())\n              console.log('targetAccount:', targetAccount);\n            }catch(err){\n              console.error('Failed getting targetAccount', err);\n              this.setState({\n                findingHash: false,\n                errors: ['Unable to load Identity/Username']\n              });\n              return false;\n            }\n            \n                  \n            // get the current value of the Second ipfshash \n            let secondHash = await targetAccount.data({key: 'ipfshash'})\n            .then(function(dataValue) {\n              let decoded = atob(dataValue.value);\n              return decoded;\n            })\n            .catch(function (err) {\n              return null;\n            })\n      \n            console.log('secondHash:', secondHash);\n            \n            \n            // secondHash = 'QmVJ9WquYQ3AaLiBckMKtFQMspb6nnrLU7LJFrNp1uqW9M';\n            \n            // Load ipfs data for hash \n            \n            this.setState({\n              hash: secondHash,\n              findingHash: false,\n              confirmed: true\n            },this.loadHashData);\n            \n          })\n        }\n        \n        @autobind\n        async loadHashData(){\n            \n          this.setState({\n            fetchingIpfs: true,\n            ipfsData: null\n          });\n          let hash = this.state.hash;\n          \n          console.log('Fetching ipfs hash:', hash);\n          \n          try {\n            let data = await universe.ipfs.files.cat(hash);\n            \n            data = JSON.stringify(JSON.parse(data),null,2);\n            \n            console.log('ipfs Data:', data);\n            \n            this.setState({\n              ipfsData: data\n            });\n            \n            \n          } catch(err){\n            \n            this.setState({\n              ipfsData: 'Failed fetching/parsing data for hash: ' + hash\n            });\n          }\n          \n          this.setState({\n            fetchingIpfs: false\n          });\n          \n        }\n\n        \n        @autobind\n        processSetup(){\n          \n          return new Promise(async(resolve,reject)=>{\n            \n            \n            this.setState({\n              connecting: true\n            })\n            \n            \n            // Need to create a local Identity, and authenticate with the remote Second to Learn from \n            // - uses a constant value (token) from the remote Second! \n            let newIdentityNode = await universe.loadAndRunCapability('Identity',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'createLocal',\n                options: {}\n              }\n            });\n            \n            \n            // Find remote Second \n            // - hash of keywords -> wallet address -> encrypted via last keyword? \n            // - want a publicKey and a URL returned \n            //   - a whole IdentityNode should be returned? \n            // - return: \n            //   - external_identity:0.0.1:local:8982f982j92\n            //   - external_identity_connect_method:0.0.1:local:382989239hsdfmn\n            \n            // let remoteValue;\n            // try {\n            //   remoteValue = WINDOW.prompt('Remote Second','test21 test21');\n            // }catch(err){\n            //   console.error('Not in Tab');\n            //   remoteValue = 'test test';\n            // }\n            \n            // console.log('Words to use for ExternalIdentity:', remoteValue);\n            \n            // // Need to create a local Identity, and authenticate with the remote Second to Learn from \n            // // - uses a constant value (token) from the remote Second! \n            // let addressNode = await universe.loadAndRunCapability('Identity',{},{\n            //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n            //   data: {\n            //     action: 'getAddressForWords',\n            //     options: {\n            //       words: remoteValue\n            //     }\n            //   }\n            // });\n            \n            // let address = addressNode.data;\n            \n            // // fetch that wallet address, get the first transaction \n            // // - first transaction contains IPFS link \n            // // - IPFS contains Nodes (without _ids!) \n            // let foundExternalIdentityNode = await universe.getIdentityForAddress(address);\n            let foundExternalIdentityNode;\n            try {\n              foundExternalIdentityNode = JSON.parse(this.state.ipfsData);\n            }catch(err){\n              WINDOW.alert('Wait for IdentityNode to load');\n              return;\n            }\n            \n            console.log('Got foundExternalIdentityNode',foundExternalIdentityNode);\n            \n            // Save ExternalIdentityNode locally! \n            let ExternalIdentityNode = await universe.loadAndRunCapability('Identity',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'saveExternal',\n                options: {\n                  ExternalIdentityNode: foundExternalIdentityNode // should contain a connection method! \n                }\n              }\n            });\n            \n            // Update local node commonName (for easy lookup) \n            ExternalIdentityNode.data.commonName = 'main';\n            let updatedExternal = await universe.updateNode(ExternalIdentityNode);\n            \n            \n            console.log('Saved new ExternalIdentityNode', ExternalIdentityNode);\n            \n            // await universe.newNode(ExternalIdentityNode);\n            \n            // return resolve({\n            //   ExternalIdentityNode,\n            //   error: true,\n            //   remoteValue,\n            //   address\n            // })\n            \n            \n            // let internalUserPassphrase;\n            // try {\n            //   internalUserPassphrase = WINDOW.prompt('Internal User Passphrase','testuserpassphrase');\n            // }catch(err){\n            //   console.error('Not in Tab');\n            //   internalUserPassphrase = 'testuserpassphrase';\n            // }\n            let internalUserPassphrase = this.state.actas;\n            \n            \n            \n            // Identify and Upgrade connection as an InternalUser (using passphrase) \n            // - this uses the newly-created ExternalIdentityNode user \n            // - also upgrades our local data.token \n            \n            try {\n              \n            // Authenticate with External Second \n            // - make authenticated requests to a Second (necessary for Learning?) \n            //   - should have ALL requests authenticated \n            // universe.setupExternalSecond();\n              \n              // Initiating Identify ...again\n              let authExternalIdentityNode2 = await universe.loadAndRunCapability('IdentifyInitiate',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'start',\n                  options: {\n                    externalIdentityPublicKey: ExternalIdentityNode.data.publicKey,\n                    // authToken: 'eeaac41bdb1b717d137a53779db97457:07e0fbe19e72c3ff7e329fc293bcf5b51d780c4c3c60f80403b2fea8f30d0daa5e4891dbdd6c57d9844622078a681853f31202d0632f0ee95031c9369a60708ddb6220e248e3c2ec6b3bb3c00eb2425aea922351d7128ef333ea5fe6a8ad139c1978759e29b057db1e655f2fe7c8962e' // \"learn\" \n                  }\n                }\n              });\n              \n              console.log('Finished IdentifyInitiate2. Starting IdentifyActAsInternalUser');\n            \n              let actAsNode = await universe.loadAndRunCapability('IdentifyActAsInternalUser',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'start',\n                  options: {\n                    externalIdentityPublicKey: ExternalIdentityNode.data.publicKey,\n                    internalUserPassphrase\n                  }\n                }\n              });\n              console.log('Finished Upgrading local identity with ActAs. actAsNode Response', actAsNode);\n              \n              \n              // Test new user (am I really ActAs?) \\\n              let e2Nodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    nodeId: null,\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      publicKey: ExternalIdentityNode.data.publicKey\n                    }\n                  }\n                }\n              });\n              let e2node = e2Nodes[0];\n              \n              console.log('e2node:', e2node);\n              \n              let e2response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: e2node,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                                \n                          {\n                            matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                            dataForAction: {\n                              type: 'string:...',\n                              data: e2node.data.token\n                            }\n                          },\n                          \n                          // {\n                          //   matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                          //   dataForAction: {\n                          //     type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                          //     data: {}\n                          //   }\n                          // }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('e2response',e2response);\n              \n            }catch(err){\n              console.error('Failed actAsNode upgrade',err);\n            }\n            \n            \n            console.log('Complete (worked!)');\n            \n            this.setState({\n              connecting: false\n            })\n            \n            universe.reinitBrowser();\n            \n            // this.handleUpdateApp();\n            \n            return resolve({\n              externalResponse: true,\n              // response,\n              codeResultNode,\n              // localResult\n            })\n            \n            \n            // Reload window (then reload the tab/session, which causes MainComponent to load) \n            \n            \n            // let IdentityNode = null;\n            // let identities = await universe.searchMemory({\n            //   filter: {\n            //     sqlFilter: {\n            //       type: 'remote_datasource:0.0.1:local:298f3h92hf9s8dhf23f'\n            //     },\n            //     // function for returning data from the Node, after filtering a bit \n            //     // - includes both the Node, and Nodes with nodeId (pointers) \n            //     filterNodes: tmpNodes=>{\n            //       // this runs isolated, outside of the above context? (not sure) \n            //       return new Promise((resolve, reject)=>{\n            //         resolve(tmpNodes);\n            //       });\n            //     },\n            //   }\n            // });\n            \n          });\n          \n        }\n        \n        @autobind\n        async handleUpdateApp(){\n          \n          // get Code and React ids from local\n          // - fetch new from Teacher \n          \n          \n          // run Capability: Teacher.updateLocal\n          // - learn from Remote \n          // universe.loadAnd\n          \n          \n          this.setState({\n            updatingLocal: true\n          });\n        \n          let response = await universe.loadAndRunCapability('Teacher',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'updateLocalCode',\n              options: {}\n            }\n          });\n          \n          // Iterate over returned \"to Update\" nodes \n          let toUpdate = response.data || [];\n          \n          console.log('Got local toUpdate', toUpdate.length, toUpdate);\n          \n          let answer;\n          try {\n            answer = WINDOW.prompt(`Overwrite local with Updates? ${toUpdate.length} changed. (y/reload)`,'reload');\n            if(!answer || ['reload','y'].indexOf(answer) === -1){\n              this.setState({\n                updatingLocal: false\n              });\n              return false;\n            }\n          }catch(err){\n            console.error(err);\n            this.setState({\n              updatingLocal: false\n            });\n            return false;\n          }\n          \n          console.log('Updating (saving locally)');\n          \n          // overwrite...\n          for(let data of toUpdate){\n            let nodeToSave = data.old;\n            nodeToSave.data.code = data.new.data.code;\n            \n            console.log('Updating Local NodeToSave:', nodeToSave);\n            let updatedNode = await universe.updateNode(nodeToSave);\n          }\n          \n          this.setState({\n            updatingLocal: false\n          });\n          \n          if(answer == 'reload'){\n            setTimeout(()=>{\n              WINDOW.location.reload();\n            },1000);\n          }\n          \n        }\n        \n        render(){\n          \n          return (\n            <div className=\"section\">\n              <div className=\"container\">\n                <div className=\"columns\">\n                  <div className=\"column is-4 is-offset-4\">\n                  \n                    <h3 className=\"title is-3\">\n                      Connect to Cloud Second\n                    </h3>\n                        \n                    <div className=\"field\">\n                      <label className=\"label\">Identity / Username</label>\n                      <div className=\"control\">\n                        <input className=\"input\" type=\"text\" placeholder=\"username/phrase\" value={this.state.username} onChange={this.updateUsername} />\n                      </div>\n                      <p className=\"help\">\n                        Converted to Stellar address. Identity is \"setup\" transaction. \n                      </p>\n                    </div>\n                    \n                        \n                    <div className=\"field\">\n                      <label className=\"label\">ActAs Passphrase</label>\n                      <div className=\"control\">\n                        <input className=\"input\" type=\"text\" placeholder=\"\" value={this.state.actas} onChange={e=>this.setState({actas: e.target.value})} />\n                      </div>\n                      <p className=\"help\">\n                        This is the passphrase you'll use to identity yourself to your Second. Determines permissions, etc. \n                      </p>\n                    </div>\n                    \n                    \n                    <div className=\"field\">\n                      <label className=\"label\">Network</label>\n                      {\n                        this.state.horizonPossible.map((horizon,i)=>(\n                          <div key={i} className=\"control\">\n                            <label className=\"radio\">\n                              <input type=\"radio\" name=\"answer\" value={i} onChange={e=>this.setState({horizonServerAddress: e.target.value})} checked={(this.state.horizonServerAddress == i)} />\n                              &nbsp;{horizon.name}\n                            </label>\n                          </div>\n                        ))\n                      }\n                    </div>\n                                        \n                    \n                    <div className=\"field is-grouped\">\n                      <div className=\"control\">\n                        <button className={\"button is-link \" + (this.state.findingHash ? 'is-loading':'')} onClick={this.confirmIdentity}>Check Identity</button>\n                      </div>\n                            \n                      {\n                        !this.state.confirmed ? '':\n                        <div className=\"control\">\n                          <button className={\"button is-success \" + (this.state.connecting ? 'is-loading':'')} onClick={this.processSetup}>Connect to Second</button>\n                        </div>\n                      }\n                      \n                    </div>\n                    \n                    {\n                      this.state.fetchingIpfs ?\n                      <div>\n                        Fetching IPFS data\n                      </div>\n                      :\n                      <div>\n                        <pre><code>{this.state.ipfsData}</code></pre>\n                      </div>\n                    }\n                    \n                  </div>\n                \n                </div>\n              \n              </div>\n              \n            </div>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
    "key": "29a65df3-924a-4fca-9d8a-0f8302166a55"
  },
  "active": true,
  "createdAt": 1519283342877,
  "updatedAt": 1521404167733
}