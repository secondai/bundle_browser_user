{
  "_id": "5a2784b49cb84d22ebce642f",
  "nodeId": "5a2784b39cb84d22ebce641d",
  "type": "code:0.0.1:local:32498h32f2",
  "data": {
    "key": "7e8bcd50-27ce-405b-a1ae-367c5d82aee4",
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      console.log('Starting ActAs Capability');\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      \n      // let newIdentityNode = await universe.loadAndRunCapability('IdentityInitiate',{},{\n      //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n      //   data: {\n      //     action: 'start',\n      //     options: {\n      //       externalIdentityPublicKey: ExternalIdentityNode,\n      //       internalUserPassphrase\n      //     }\n      //   }\n      // });\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      let { externalIdentityPublicKey, internalUserPassphrase } = inputOpts;\n      \n      switch(inputAction){\n        case 'start':\n          break;\n          \n        default:\n          return reject();\n      }\n      \n      \n      // Currently ExternalIdentity is unique by the publicKey (cant have multiple identities with the same publicKey) \n      // - can have multiple connect_method's though! (websocket, etc.) \n      \n      \n      // Upgrades token (gets a new token for ExternalIdentityNode, updates local memory) \n      //- adds InternalUser for remote \n      \n      \n      // Get local ExternalIdentity \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: externalIdentityPublicKey\n            }\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            return tmpNodes;\n          }\n        }\n      });\n      \n      if(!nodes.length){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity node',\n            publicKey: INPUT.data\n          }\n        })\n      }\n      \n      let ExternalIdentityNode = nodes[0];\n      \n      \n      // // has connect_method (external_identity_connect_method:0.0.1:local:382989239hsdfmn)?\n      // let connectNode = universe.lodash.find(ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n      // if(!connectNode){\n      //   return resolve({\n      //     type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n      //     data: {\n      //       str: 'Missing existing ExternalIdentity connect_method child!'\n      //     }\n      //   })\n      // }\n      \n      \n      \n      // TalkToSecond (runs sequence of auth w/ token, then upgrade) \n      console.log('Token FOR ActAs:', ExternalIdentityNode.data.token, ExternalIdentityNode);\n      let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n        type: 'standard_capability_action:0.0.1:local:298j291bs',\n        data: {\n          action: 'send',\n          options: {\n            ExternalIdentityNode,\n            RequestNode: {\n              type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n              data: {\n                actions: [\n                        \n                  {\n                    matchActionType: 'identify_via_token:0.0.1:local:237823783g2123',\n                    dataForAction: {\n                      type: 'string:...',\n                      data: ExternalIdentityNode.data.token\n                    }\n                  },\n                  \n                  {\n                    matchActionType: 'identify_token_upgrade_to_internal_user:0.0.1:local:9281198u',\n                    dataForAction: {\n                      type: 'user_passphrase:0.01...',\n                      data: {\n                        passphrase: internalUserPassphrase\n                      }\n                    }\n                  }\n                ]\n                \n              }\n            }\n          }\n        }\n      });\n      \n      console.log('ActAs Response:', response);\n      \n      // expecting type: upgrade_token_response:0.0.1:local:289fh2389h23sfsvds\n      \n      let tokenResponse = response.data.actionResponses[1];\n      if(tokenResponse.type != 'upgrade_token_response:0.0.1:local:289fh2389h23sfsvds'){\n        console.error('Failed Identity Upgrade to InternalUser');\n        return reject({\n          msg: 'Failed Identity Upgrade to InternalUser', \n          error: true\n        })\n      }\n      let newToken = tokenResponse.data.token;\n      \n      console.log('newToken for ActsAs:', newToken);\n      \n      // Update/save local ExternalIdentityNode with new token \n      ExternalIdentityNode.data.token = newToken;\n      let updatedExternalIdentityNode = await universe.updateNode(ExternalIdentityNode);\n      \n      console.log('Updated local ExternalIdentityNode', updatedExternalIdentityNode);\n      \n      return resolve({\n        type: 'identity_upgrade_finish:0.0.1:local:981h3001j3',\n        data: {\n          updatedExternalIdentityNode,\n          newToken\n        }\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()"
  },
  "active": true,
  "createdAt": 1512539316534,
  "updatedAt": 1513150353107
}