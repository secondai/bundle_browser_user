{
  "_id": "5ac679436ce165001d7acb12",
  "nodeId": "5ac47ae265eb53001d56081e",
  "type": "react_component:0.0.1:local:98912hd89",
  "data": {
    "version": "1",
    "code": "(()=>{\n  \n  \n  let __parsedFiles = {};\n  function jsonParse(key, contents){\n    if(__parsedFiles[key]){\n      return __parsedFiles[key]\n    }\n  \n    __parsedFiles[key] = JSON.parse(contents);\n    return __parsedFiles[key];\n  \n  }\n  \n  \n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            mainTab: '__ALL__',\n            aceHeight: 100,\n            windowHeight: 100,\n            pastable: false,\n            pasteText: '',\n            isPublishing: false,\n            saving: false,\n            updatingGit: false,\n            chainNodes: [],\n            nodeChains: null\n          }\n        }\n        \n        componentDidMount(){\n          console.log('Editor componentDidMount2');\n          this.resizeAce();\n          this.handleKeyDown();\n          \n          this.loadSchema();\n          this.fetchParentsOfNodesToLearn();\n          this.checkForCodeUpdates();\n          \n          universe.EE.on('nodes-modified', this.fetchParentsOfNodesToLearn);\n          universe.EE.on('nodes-modified', this.loadSchema);\n          universe.EE.on('nodes-modified', this.checkForCodeUpdates);\n          \n        }\n        \n        componentWillUnmount(){\n          \n          universe.EE.removeListener('nodes-modified', this.fetchParentsOfNodesToLearn);\n          universe.EE.removeListener('nodes-modified', this.loadSchema);\n          universe.EE.removeListener('nodes-modified', this.checkForCodeUpdates);\n          \n        }\n        \n        componentWillReceiveProps(nextProps, nextState){\n          \n          // resizing helpers for Ace height\n          if(!nextProps.state.newWindowSize || \n            this.state.windowHeight != nextProps.state.newWindowSize[1]){\n            this.setState({\n              aceHeight: 0\n            },()=>{\n              this.resizeAce();\n            })\n          }\n          if(nextState.aceHeight == -1){\n            this.setState({\n              aceHeight: 0\n            },()=>{\n              this.resizeAce();\n            })\n          }\n          // if(nextProps.state.editingNode && this.props.node){\n          //   if(nextProps.state.editingNode._id != this.props.node._id){\n          //     this.setState({\n          //       mainTab: '__ALL__'\n          //     })\n          //   }\n          // }\n          // console.log('nextProps:', nextProps);\n        }\n        \n        @autobind\n        resizeAce(){\n          if(!this.parentRef){\n            this.setState({\n              aceHeight: null\n            })\n            return;\n          }\n          // console.log('Resize ace', this.parentRef.offsetHeight);\n          this.setState({\n            aceHeight: this.parentRef.offsetHeight\n          },()=>{\n            if(this.aceRef){\n              this.aceRef.editor.resize();\n            }\n          })\n        }\n        \n        @autobind\n        refetchNode(){\n          return new Promise(async (resolve,reject)=>{\n            \n            let node = this.props.node;\n              \n            try {\n              \n              this.setState({\n                fetchingRemote: true\n              })\n              \n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      if(inputNode._id != '${node._id}'){\n                                        return false;\n                                      }\n                                      \n                                      return inputNode;\n                                      \n                                    })()`\n                                  }\n                                },\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              let nodes = response.data.actionResponses[0].data;\n              \n              // expecting single result \n              // let componentNode = await universe.runInVM(result[0],{});\n              \n              // this resets the component! (remount, etc.) \n              this.props.setState({\n                editingNode: nodes[0]\n              })\n              \n              resolve();\n              \n              \n            } catch(err){\n              console.error('Failed refetching editingNode');\n              \n              this.setState({\n                fetchingRemote: false\n              })\n              \n              reject();\n              \n            }\n            \n          });\n          \n          // this.props.setState({\n          //   editingNode: node\n          // })\n          \n        }\n      \n        @autobind\n        async loadSchema(){\n          // from NodeChain \n          // - temporarily using an odd slug (without ipfs hash) \n          \n          // let slug = this.props.node.type;\n          let slug = this.props.editStateToObj().type;\n          \n          console.log('LOAD SCHEMA1');\n            \n          let parsed = slug.split(':');\n          if(parsed[1].slice(0,2) == 'Qm'){\n            console.log('IPFS Hash:', parsed[1]);\n            \n            let fileNode = await universe.ipfs.files.cat(parsed[1]);\n            console.log('fileNode:', fileNode);\n            fileNode = JSON.parse(fileNode);\n            let schemaObj = fileNode.data.schema;\n            \n            // choose default tab if exists\n            let mainTab = this.state.mainTab;\n            try {\n              if(schemaObj.properties.code){\n                mainTab = 'code';\n              }\n            }catch(err){}\n            \n            this.setState({\n              schema: schemaObj, // jsSchema\n              mainTab\n            })\n            \n          } else {\n            // find from NodeChain API \n            // - temporary \n            // - first where data.slug matches \n            console.log('Find from NodeChain API');\n            let nested = [{\n              key: 'data.slug',\n              value: slug\n            }];\n            // let data = JSON.parse('{\"operationName\":null,\"variables\":{\"nested\":null},\"query\":\"query ($nested: JSON) {  viewer { node { one(filter: {nested: $nested}) {    _id    data    __typename  }}}}\"}');\n            // data.variables.nested = nested;\n            // console.log('data to post:', data);\n            if(!this.props.state.LanguageChainNode){\n              console.error('Waiting for this.props.state.LanguageChainNode');\n            }\n            let chainNode = await universe.findOnNodeChain({\n              method: 'one',\n              nested,\n              chainPubKey: this.props.state.LanguageChainNode.data.pubKey,\n              apiAddress: this.props.state.LanguageChainNode.data.apiAddress,\n            });\n          \n        \n            let schemaObj = chainNode.data.schema;\n            \n            // choose default tab if exists\n            let mainTab = this.state.mainTab;\n            try {\n              if(schemaObj.properties.code){\n                mainTab = 'code';\n              }\n            }catch(err){}\n            \n            this.setState({\n              schema: schemaObj, // jsSchema\n              mainTab\n            })\n            \n            // universe.$.ajax({\n            //   url: 'https://api.getasecond.com/graphql',\n            //   method: 'post',\n            //   contentType: 'application/json',\n            //   data: JSON.stringify(data),\n            //   success: nodeChainResult=>{\n            //     console.log('NodeChain Result', nodeChainResult);\n            //     if(!nodeChainResult.data.viewer.node.one){\n            //       console.error('Missing Schema for this type!');\n            //       this.setState({\n            //         schema: false\n            //       })\n            //       return;\n            //     }\n            //     console.log('have Schema:', nodeChainResult);\n                \n            //     let schemaObj = nodeChainResult.data.viewer.node.one.data.schema;\n                \n            //     // choose default tab if exists\n            //     let mainTab = this.state.mainTab;\n            //     try {\n            //       if(schemaObj.properties.code){\n            //         mainTab = 'code';\n            //       }\n            //     }catch(err){}\n                \n            //     this.setState({\n            //       schema: schemaObj, // jsSchema\n            //       mainTab\n            //     })\n            //   },\n            //   error: err=>{\n            //     console.error('Failed fetching languages:', err);\n            //   }\n            // })\n            \n          }\n          \n        }\n      \n        @autobind\n        loadSchemaOLD(slug){\n          // from Languages server \n      \n          let data = JSON.parse('{\"operationName\":null,\"variables\":{\"slug\":\"'+slug+'\"},\"query\":\"query ($slug: String) {  viewer { language { one(filter: {slug: $slug}) {    _id    slug    title    schemaCode    schemaObj    createdAt    updatedAt    __typename  }}}}\"}');\n          data = JSON.stringify(data);\n          universe.$.ajax({\n            url: 'http://lang.second.ngrok.io/graphql',\n            method: 'post',\n            contentType: 'application/json',\n            data: data,\n            success: languageResult=>{\n              // console.log('Languages', languageResult);\n              if(!languageResult.data.viewer.language.one){\n                console.error('Missing Schema for this type!');\n                this.setState({\n                  schema: false\n                })\n                return;\n              }\n              console.log('have Schema:', languageResult);\n              \n              let schemaObj = languageResult.data.viewer.language.one.schemaObj;\n              \n              // choose default tab if exists\n              let mainTab = this.state.mainTab;\n              try {\n                if(schemaObj.properties.code){\n                  mainTab = 'code';\n                }\n              }catch(err){}\n              \n              this.setState({\n                schema: schemaObj, // jsSchema\n                mainTab\n              })\n            },\n            error: err=>{\n              console.error('Failed fetching languages:', err);\n            }\n          })\n      \n        }\n      \n        @autobind\n        async saveDataUpdates(){\n        \n          console.log('Saving updates');\n      \n          let dataBeforeParse = this.props.editState.fields.data.value;\n      \n          let realData;\n    \n          try {\n            realData = JSON.parse(dataBeforeParse);\n          }catch(err){\n            return false;\n          }\n      \n          // create it on the server \n          let nodeToSave = {\n            _id: this.props.node._id,\n            data: realData, // type should be correct! ,\n            updatedAt: (new Date()).getTime()\n            // schemaObj: JSON.parse(outputVal)\n          }\n          \n          this.makeSaveRequest(nodeToSave);\n        \n        }\n        \n        @autobind\n        fetchParentsOfNodesToLearn(){\n          return new Promise(async (resolve, reject)=>{\n            \n            this.setState({\n              fetchingParents: true\n            })\n            \n            let parentNodes = [];\n            try {\n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      if(inputNode.nodeId){\n                                        return false;\n                                      }\n                                      \n                                      if(inputNode.type.split(':')[0] != \"parent_of_nodes_to_learn\"){\n                                        return false;\n                                      }\n                                      \n                                      if(inputNode.data.environment != \"browser\"){\n                                        return false;\n                                      }\n                                      \n                                      return inputNode;\n                                      \n                                    })()`\n                                  }\n                                },\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              parentNodes = response.data.actionResponses[0].data;\n              \n              console.log('parentNodes updated');\n            }catch(err){\n              console.error('Failed updating parentNodes');\n            }\n            \n            this.setState({\n              parentNodes,\n              fetchingParents: false\n            })\n            \n            resolve(parentNodes);\n            \n          });\n        }\n      \n        @autobind\n        async handleUpdateType(){\n        \n          let type = WINDOW.prompt('Type:',this.props.node.type);\n          if(!type){\n            return false;\n          }\n    \n          type = type.trim();\n\n          // create it on the server \n          let nodeToSave = {\n            _id: this.props.node._id,\n            type, // type should be correct! ,\n            updatedAt: (new Date()).getTime()\n            // schemaObj: JSON.parse(outputVal)\n          }\n          \n          this.makeSaveRequest(nodeToSave);\n        \n        }\n      \n        @autobind\n        async handleUpdateParent(){\n          \n          console.log('Node:', this.props.node);\n          \n          let nodeId = WINDOW.prompt('Parent Node ID:',this.props.node.nodeId || '');\n          if(!nodeId){\n            return false;\n          }\n    \n          nodeId = nodeId.trim();\n          \n          if(!nodeId.length){\n            nodeId = null;\n          }\n  \n          // create it on the server \n          let nodeToSave = {\n            _id: this.props.node._id,\n            nodeId,\n            updatedAt: (new Date()).getTime()\n            // schemaObj: JSON.parse(outputVal)\n          }\n          \n          this.makeSaveRequest(nodeToSave);\n        \n        }\n      \n        @autobind\n        handleDuplicate(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            // let node = this.props.node;\n            let node = this.props.editStateToObj();\n      \n            let doParent;\n            if(node.nodeId){\n              doParent = WINDOW.prompt('Keep parent? (y/n)','y');\n              if(!doParent){\n                return false;\n              }\n            }\n      \n            let doChildren;\n            if(node.nodes && node.nodes.length){\n              doChildren = WINDOW.prompt('Keep child nodes? (y/n)','y');\n              if(!doChildren){\n                return false;\n              }\n            }\n      \n            console.log('NODE:', node);\n      \n            // // Send in a Node that will be learned by the AI \n            // {\n            //   type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n            //   data: {\n            //     // what to import! \n            //     _id: \"testingid2\",\n            //     nodeId: null,\n            //     type: \"emoji:0.0.1:local:2f9jsd98fj293fsdf\",\n            //     // expected/allowed schemas for return \n            //     data: {\n            //       emoji: \"joy\"\n            //     }\n            //   }\n            // },\n      \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Save for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n            \n            // New key, if CodeNode?\n            \n            let newKey;\n            if(node.data && node.data.key){\n              newKey = WINDOW.prompt('New uuid key for CodeNode?','y');\n              if(newKey == 'y'){\n                newKey = universe.uuidv4();\n              } else {\n                newKey = null;\n              }\n            }\n      \n            this.setState({\n              saving: true\n            });\n      \n            // iterate\n            // - save this one, then start saving down tree\n            let newNode = {\n              nodeId: (doParent === 'y') ? node.nodeId:null,\n              type: node.type,\n              data: JSON.parse(JSON.stringify(node.data)),\n            }\n            \n            if(newKey){\n              newNode.data.key = newKey;\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true}, true);\n            \n            console.log('Saved Node');\n          \n            const saveChildNodes = (nodeId, childNodes) => {\n              return new Promise(async (resolve, reject)=>{\n      \n                console.log('Saving children');\n                \n                for(let tmpNode of childNodes){\n                  let newChildNode = {\n                    nodeId,\n                    type: tmpNode.type,\n                    data: tmpNode.data,\n                  }\n                  let savedChildNode = await this.forceNewNode(newChildNode, {skipExistingLearnedNodeId: true}, true);\n      \n                  if(tmpNode.nodes && tmpNode.nodes.length){\n      \n                    await saveChildNodes(savedChildNode.data._id, tmpNode.nodes);\n      \n                  }\n                }\n                resolve();\n              });\n            }\n      \n            if(doChildren){\n              await saveChildNodes(savedNode.data._id, node.nodes);\n            }\n            \n            console.log('Done duplicating');\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n            this.setState({\n              saving: false\n            });\n      \n            // window.location = '/node/' + savedNode._id;\n      \n          });\n      \n        }\n      \n        @autobind\n        handleAddChild(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            // let node = this.props.node;\n            let node = this.props.editStateToObj();\n      \n            let type;\n            type = WINDOW.prompt('Type?','');\n            if(!type){\n              return false;\n            }\n            \n            type = type.trim();\n            \n            // todo: get and validate the type's schema. use schema for default data\n            \n            this.setState({\n              saving: true\n            });\n      \n            let newNode = {\n              nodeId: node._id,\n              type: type,\n              data: null\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true});\n            \n            console.log('Saved Node', savedNode);\n          \n            console.log('Done creating new');\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n            this.setState({\n              saving: false\n            });\n      \n            // window.location = '/node/' + savedNode._id;\n      \n          });\n      \n        }\n        \n        @autobind\n        handleAddChildPaste(){\n          \n          return new Promise(async (resolve,reject)=>{\n      \n            let nodeText = this.state.pasteText; //WINDOW.prompt('Node JSON String','');\n            if(!nodeText){\n              return false;\n            }\n            \n            let nodes = JSON.parse(nodeText);\n            console.log('Nodes input:', nodes);\n            \n            // Single Node, or Multiple? \n            if(!universe.lodash.isArray(nodes)){\n              // single node\n              nodes = [nodes];\n            }\n            \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Save node(s) and children for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n            \n            for(let node of nodes){\n            \n              // iterate\n              // - save this one, then start saving down tree\n              let newNode = {\n                nodeId: this.props.node._id, \n                type: node.type,\n                data: node.data,\n              }\n        \n              console.log('newNode:', newNode);\n        \n              let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true}, true);\n              \n              console.log('Saved Node');\n            \n              const saveChildNodes = (nodeId, childNodes) => {\n                return new Promise(async (resolve, reject)=>{\n        \n                  console.log('Saving children');\n                  \n                  for(let tmpNode of childNodes){\n                    let newChildNode = {\n                      nodeId,\n                      type: tmpNode.type,\n                      data: tmpNode.data,\n                    }\n                    let savedChildNode = await this.forceNewNode(newChildNode, {skipExistingLearnedNodeId: true}, true);\n        \n                    if(tmpNode.nodes && tmpNode.nodes.length){\n        \n                      await saveChildNodes(savedChildNode.data._id, tmpNode.nodes);\n        \n                    }\n                  }\n                  resolve();\n                });\n              }\n        \n              await saveChildNodes(savedNode.data._id, node.nodes);\n              \n            }\n            \n            console.log('Done Adding via Paste');\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n          });\n        }\n        \n        @autobind\n        handleImportZip(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            let url = WINDOW.prompt('ZIP URL (github urls parsed automatically)',''); \n            if(!url){\n              return false;\n            }\n            \n        \n            // converts startup git url into username/password \n            // - eventually allow links to be pasted, parse accordingly \n        \n            // parse github links and re-organize to fit .zip model \n        \n            this.setState({\n              saving: true\n            });\n            \n            let gh = universe.parseGitHubUrl(url);\n            if(gh.owner && \n              gh.name && \n              gh.repo && \n              gh.branch){\n              url = `https://github.com/${gh.repo}/archive/${gh.branch}.zip`;\n            }\n        \n            // cannot simply follow github zipball/tarball links :( \n            universe.fetch(`https://cors-anywhere.herokuapp.com/${url}`,{\n              // mode: 'no-cors' \n            })\n            .then(response=>{\n              // console.log('Response:', response);\n              return response.arrayBuffer();\n            })\n            .then(universe.JSZip.loadAsync)\n            .then(async (zip)=>{\n              \n              console.log('loaded zip data!', zip);\n      \n              // ZIP is valid! \n              let files = zip.files;\n      \n              function readFilePath(p){\n                return new Promise(async (resolve,reject)=>{\n                  console.log('path:', p);\n                  let r = await files[p].async('text')\n                  resolve(r);\n                });\n              }\n      \n              // load all the files \n              let allFiles = {};\n              for(let filepath of Object.keys(files)){\n                let file = files[filepath];\n                if(file.dir){\n      \n                } else {\n                  // console.log('filepath:', filepath);\n                  let contents = await readFilePath(filepath);\n                  // console.log('contents:', contents);\n                  let normalizedPath = filepath.split('/').splice(1).join('/');\n                  allFiles[normalizedPath] = contents;\n                }\n              }\n      \n              console.log('allFiles from Zip:', allFiles);\n              \n              function addChildren(id){\n                return new Promise(async (resolve,reject)=>{\n            \n                  let nodes = [];\n                    for(let filepath of Object.keys(allFiles)){\n                    let contents = allFiles[filepath];\n                    if(filepath.indexOf('nodes/') !== 0){\n                      // console.log('NOT NODE:', filepath);\n                      continue;\n                    }\n      \n                    let parsed = jsonParse(filepath, contents);\n                    if(parsed.nodeId == id){\n                      // console.log('Matches ID:', parsed.nodeId, id);\n                      let children = await addChildren(parsed._id);\n                      parsed.nodes = children;\n                      nodes.push(parsed);\n                    } else {\n                      // console.log('No Kids:', id, parsed.nodeId);\n                    }\n      \n                  }\n      \n                  resolve(nodes);\n      \n                });\n              }\n      \n              // re-organize child nodes \n              let ZipNodes;\n              try {\n                ZipNodes = await addChildren(null); // start at root, adds children recursively \n              }catch(err){\n                console.error('Failed zipnodes', err);\n                WINDOW.alert('Failed fetching zip nodes');\n              }\n        \n              console.log('ZipNodes:', ZipNodes);\n              \n              // let secondJson = JSON.parse(allFiles['second.json']);\n              // let basicKey = secondJson.name; \n              \n              \n              for(let node of ZipNodes){\n              \n                // iterate\n                // - save this one, then start saving down tree\n                let newNode = {\n                  nodeId: this.props.node._id, \n                  type: node.type,\n                  data: node.data,\n                }\n          \n                console.log('newNode:', newNode);\n          \n                let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true}, true);\n                \n                console.log('Saved Node');\n              \n                const saveChildNodes = (nodeId, childNodes) => {\n                  return new Promise(async (resolve, reject)=>{\n          \n                    console.log('Saving children');\n                    \n                    for(let tmpNode of childNodes){\n                      let newChildNode = {\n                        nodeId,\n                        type: tmpNode.type,\n                        data: tmpNode.data,\n                      }\n                      let savedChildNode = await this.forceNewNode(newChildNode, {skipExistingLearnedNodeId: true}, true);\n          \n                      if(tmpNode.nodes && tmpNode.nodes.length){\n          \n                        await saveChildNodes(savedChildNode.data._id, tmpNode.nodes);\n          \n                      }\n                    }\n                    resolve();\n                  });\n                }\n          \n                await saveChildNodes(savedNode.data._id, node.nodes);\n                \n              }\n              \n              console.log('Done Adding via Zip');\n          \n              this.setState({\n                saving: false\n              });\n              \n              try {\n                universe.EE.emit('nodes-modified', '');\n              }catch(err){\n                console.error(err);\n              }\n      \n      \n            })\n\n            \n          });\n          \n        }\n      \n        @autobind\n        handleExportNode(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let node = JSON.parse(JSON.stringify(this.props.editStateToObj()));\n            // let node = JSON.parse(JSON.stringify(this.props.node));\n      \n            let confirm;\n            confirm = WINDOW.confirm('Export as JSON (copied to clipboard)?');\n            if(!confirm){\n              return false;\n            }\n            \n            // JSON-ify, export to be imported into browser/etc.\n            // - for the \"learn basics\" Nodes (default ExternalIdentity, capabilities, etc.) \n            let j = JSON.stringify(node);\n            WINDOW.tmpJ = j;\n            // console.log('JSON-ified:', j);\n            // WINDOW.prompt('JSON',WINDOW.btoa(j));\n            universe.copy(j);\n            \n          });\n      \n        }\n      \n        @autobind\n        handleExportChildren(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            // let node = JSON.parse(JSON.stringify(this.props.node));\n            let node = JSON.parse(JSON.stringify(this.props.editStateToObj()));\n      \n            let confirm;\n            confirm = WINDOW.confirm('Export as JSON (copied to clipboard)?');\n            if(!confirm){\n              return false;\n            }\n            \n            let nodes = node.nodes || [];\n            nodes = nodes.map(node=>{\n              delete node.nodeId;\n              return node;\n            })\n            \n            console.log('NODES:', nodes);\n            \n            // JSON-ify, export to be imported into browser/etc.\n            // - for the \"learn basics\" Nodes (default ExternalIdentity, capabilities, etc.) \n            let j = JSON.stringify(nodes);\n            WINDOW.tmpJ = j;\n            // console.log('JSON-ified:', j);\n            // WINDOW.prompt('JSON',WINDOW.btoa(j));\n            universe.copy(j);\n            \n          });\n      \n        }\n      \n        @autobind\n        handleExportChildrenToLocalStorage(){\n          \n          return new Promise(async (resolve,reject)=>{\n      \n            // let node = JSON.parse(JSON.stringify(this.props.node));\n      \n            let node = JSON.parse(JSON.stringify(this.props.editStateToObj()));\n            let nodes = node.nodes || [];\n            \n            console.log('Local Node Repo Info:', this.props.node.data);\n            \n            let storageKey = this.props.node.data.repo;\n            \n            \n            let confirm;\n            confirm = WINDOW.confirm('Will overwrite: ' + storageKey);\n            if(!confirm){\n              return false;\n            }\n            \n            // Find the node from the storageKey! \n            // - must be stored in a parent_of_nodes_to_learn tree \n            \n            // parent_of_nodes_to_learn:0.0.1:local:2839fh29\n          \n            // let node = universe.lodash.find(this.state.parentNodes,n=>{\n            //   return n.data.learn == storageKey;\n            // });\n            // console.log('NODE:', node, this.state.parentNodes);\n            // let nodes = JSON.parse(JSON.stringify(node.nodes || []));\n            nodes = nodes.map(node=>{\n              delete node.nodeId;\n              return node;\n            })\n            \n            console.log('NODES:', nodes);\n            \n            // JSON-ify, export to be imported into browser/etc.\n            // - for the \"learn basics\" Nodes (default ExternalIdentity, capabilities, etc.) \n            // let j = JSON.stringify(nodes);\n            // WINDOW.tmpJ = j;\n            // console.log('JSON-ified:', j);\n            // WINDOW.prompt('JSON',WINDOW.btoa(j));\n            // universe.copy(j);\n            \n            let uiApps = await localforage.getItem('possible-ui-apps');\n            uiApps = uiApps || {};\n            \n            uiApps[storageKey] = nodes;\n            \n                  \n            let updatedApps = await localforage.setItem('possible-ui-apps', uiApps);\n            \n            \n            \n          });\n      \n        }\n      \n        @autobind\n        handleExportChildrenToGitHub(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            // let node = JSON.parse(JSON.stringify(this.props.node));\n            let node = JSON.parse(JSON.stringify(this.props.editStateToObj()));\n      \n            let confirm;\n            confirm = WINDOW.confirm('Overwrite Nodes in github repo?');\n            if(!confirm){\n              return false;\n            }\n            \n            \n            let nodes = node.nodes || [];\n            \n            // remove nodeId from new \"root\" nodes \n            nodes = nodes.map(node=>{\n              delete node.nodeId;\n              return node;\n            })\n            \n            console.log('NODES:', nodes);\n            \n            let nodesToWrite = {};\n            \n            function handleNodes(nodes){\n            \n            \tnodes.forEach(tmpNode=>{\n            \t\t// console.log(node);\n            \t\tlet node = JSON.parse(JSON.stringify(tmpNode));\n            \n            \t\tdelete node.parent;\n            \t\tdelete node.nodes;\n            \n            \t\tnodesToWrite[node._id + '.json'] = JSON.stringify(node,null,2);\n            \n            \t\tif(tmpNode.nodes && tmpNode.nodes.length){\n            \t\t\t// fs.mkdirSync('./nodes/');\t\n            \t\t\thandleNodes(tmpNode.nodes)\n            \t\t}\n            \n            \t})\n            }\n            \n            handleNodes(nodes);\n            \n            \n            // actually write files to github\n            console.log('nodesToWrite:', nodesToWrite);\n            \n            let ghAuth = universe.localStorage.getItem('gh_auth') || '';\n            \n            console.log('ghAuth:', ghAuth);\n            \n            let ghUser;\n            let ghToken;\n            try {\n              if(!ghAuth){\n                ghUser = WINDOW.prompt('GitHub Username:', '');\n                ghToken = WINDOW.prompt('OAuth Token:', '');\n                if(!ghUser || !ghToken){\n                  return false;\n                }\n                ghAuth = [ghUser, ghToken].join(':');\n                universe.localStorage.setItem('gh_auth', ghAuth);\n              }\n              \n              ghUser = ghAuth.split(':')[0];\n              ghToken = ghAuth.split(':')[1];\n            }catch(err){\n              console.error('Failed ghAuth:', err);\n              return false;\n            }\n            \n            console.log('Setting state...', this, this.setState);\n            \n            this.setState({\n              updatingGit: 'Starting'\n            })\n            \n            // use pre-generated OAuth token for basic auth \n            try {\n              \n              console.log('Local Node Repo Info:', this.props.node.data);\n              \n              const gh = new universe.GitHub({\n                username: ghUser,\n                password: ghToken\n              });\n              \n              let Repo = gh.getRepo(this.props.node.data.owner, this.props.node.data.repo);\n              \n              console.log('Repo:', Repo);\n              \n              // Create a new Branch, not commit directory to master  \n              // - squash commits when merging!\n              let tmpBranch = 'tmp-' + (new Date()).getTime();\n              await Repo.createBranch(this.props.node.data.defaultBranch, tmpBranch);\n              \n              // Get shas for files in directory (use getContents) \n              let {data} = await Repo.getContents(tmpBranch, 'nodes/')\n              // .then(({data})=>{\n                console.log('Got repo contents:', data);\n              // })\n              \n              \n              // check nodes in github \n              // - missing nodes should be deleted \n              let changes = 0;\n              let toRemove = [];\n              let ghFilesByName = {};\n              for(let node of data){\n                ghFilesByName[node.name] = node;\n                if(!nodesToWrite[ node.name ]){\n                  // missing, nodes should be removed\n                  // toRemove.push(node.path); // \"path\" includes \"nodes/\"...\n                  console.log('Removing:', node.name);\n                  changes++;\n                    \n                  this.setState({\n                    updatingGit: 'Removing ' + node.name\n                  })\n                  \n                  await Repo.deleteFile(tmpBranch, node.path);\n                      \n                  \n                }\n              }\n              \n              // check nodes locally\n              // - some nodes should be updated \n              // - some nodes will be new \n              for(let name of Object.keys(nodesToWrite)){\n                if(ghFilesByName[name]){\n                  // exists, update necessary? \n                  \n                  // sha1(\"blob \" + filesize + \"\\0\" + data)\n                  let newSha = universe.SHA1(\"blob \" + nodesToWrite[name].length + \"\\0\" + nodesToWrite[name]).toString();\n                  \n                  if(newSha == ghFilesByName[name].sha){\n                    console.log('No Change:', name);\n                  } else {\n                    console.log('Updated:', name, newSha, ghFilesByName[name].sha);\n                    changes++;\n                    // delete first, so that squashed merge works later! \n                    \n                    this.setState({\n                      updatingGit: 'Updating ' + name\n                    })\n                    \n                    await Repo.deleteFile(tmpBranch, 'nodes/' + name);\n                    await Repo.writeFile(tmpBranch, 'nodes/' + name, nodesToWrite[name], 'commit message', {\n                      encode: true\n                    });\n                      \n                    \n                  }\n                } else {\n                  // doesnt exist, write new! \n                  console.log('New', name);\n                  changes++;\n                  \n                  this.setState({\n                    updatingGit: 'Adding ' + name\n                  })\n                  \n                  await Repo.writeFile(tmpBranch, 'nodes/' + name, nodesToWrite[name], 'commit message', {\n                    encode: true\n                  });\n                  \n                }\n              }\n              \n              // console.log('WRITING');\n              // await Repo.writeFile(tmpBranch, 'nodes/test.json1', '{}', 'commit message', {\n              //   encode: true\n              // });\n              \n              if(changes){\n              \n                this.setState({\n                  updatingGit: 'Create Temp PR'\n                })\n                \n                let pr = await Repo.createPullRequest({\n                  title: 'Temporary Pull Request, should auto-remove in moments',\n                  head: [this.props.node.data.owner, tmpBranch].join(':'),\n                  base: this.props.node.data.defaultBranch\n                });\n                \n                console.log('PR:', pr);\n                \n                console.log('PR Number:', pr.data.number);\n                \n                this.setState({\n                  updatingGit: 'Merge Temp PR'\n                })\n                \n                let merged = await Repo.mergePullRequest(pr.data.number, {\n                  commit_title: 'squashed merge title',\n                  commit_message: 'squashed merge message',\n                  merge_method: 'squash'\n                });\n                \n                console.log('merged', merged);\n              } else {\n                // no PR necessary, no changes made! \n              }\n              \n              this.setState({\n                updatingGit: 'Remove Branch'\n              })\n              \n              // delete tmp branch (remove reference?)  \n              await Repo.deleteRef(`heads/${tmpBranch}`);\n              \n              if(changes){\n                WINDOW.alert('Changes made: ' + changes);\n              } else {\n                WINDOW.alert('No Changes to Make!');\n              }\n              \n              this.setState({\n                updatingGit: false\n              })\n              \n              console.log('Done, cleaned up tmpBranch!');\n              \n              \n            }catch(err){\n              console.error('Failed github',err);\n            }\n            \n          });\n      \n        }\n        \n        @autobind\n        handleClearGitHubCredentials(){\n          universe.localStorage.removeItem('gh_auth');\n          WINDOW.alert('Credentials cleared');\n        }\n      \n        @autobind\n        handleGetLatestCodeNode(){\n          return new Promise(async (resolve,reject)=>{\n            // gets NodeChain ref's matching node.data.internalId\n            // - useful for checking if a CodeNode has an update (or exists?)? \n            \n            console.log('Updating with latest code! TODO');  \n            \n          });\n        }\n      \n        @autobind\n        handleChangeNodeChainData(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            console.log('handleChangeNodeChainData');\n            \n            // whole object\n            let node = this.props.editStateToObj();\n          \n            let nodeChains = this.state.nodeChains;\n            if(!nodeChains){\n              nodeChains = await this.fetchNodeChains();\n            }\n            let chainOptions = \"Choose Chain:\\n\" + nodeChains.map((n,i)=>{\n              return [i+1,'. ', n.data.username].join('')\n            }).join(\"\\n\");\n            let chosenChain = WINDOW.prompt(chainOptions,'1');\n            if(!chosenChain){\n              this.setState({\n                isPublishing: false\n              })\n              return false;\n            }\n            \n            let tmpNodeChainInfo = nodeChains[parseInt(chosenChain,10)-1];\n            \n            console.log('chosenChain', chosenChain, '(subtract 1)', nodeChains, tmpNodeChainInfo);\n            \n            if(!tmpNodeChainInfo){\n              WINDOW.alert('INVALID nodechain specified');\n              this.setState({\n                isPublishing: false\n              })\n              return false;\n            }\n            \n            // strip extra from node (_id, createdAt, etc.) \n            let nodeChainInfo = JSON.parse(JSON.stringify(tmpNodeChainInfo));\n            node.data.nodeChainNode = {\n              type: nodeChainInfo.type,\n              data: nodeChainInfo.data,\n            }\n          \n            // update on remote second\n            let nodeToSave = {\n              _id: node._id,\n              data: node.data, // type should be correct! ,\n              updatedAt: (new Date()).getTime()\n            }\n            \n            console.log('Updating Node:', nodeToSave);\n            await this.makeSaveRequest(nodeToSave);\n            \n        \n            // update whole Node \n            // - easier than updating individual parts for now\n            this.refetchNode();\n            \n            \n          });\n      \n        }\n      \n        @autobind\n        handleExportToNodeChain(){\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            console.log('handleExportToNodeChain');\n            \n            // whole object\n            let node = this.props.editStateToObj();\n          \n            console.log('Node For Chain:', node);\n        \n            // let node = JSON.parse(JSON.stringify(this.props.node));\n            let ref = node.data.key;\n            let version = (node.data.version || 1).toString();\n            let author = node.data.author;\n            \n            let nodeChainInfo = node.data.nodeChainNode;\n            \n            if(!ref){\n              return WINDOW.alert('Missing key (uuid) for node. Required for publishing new node (used for \"ref\")');\n            }\n            \n            this.setState({\n              isPublishing: true\n            })\n            \n            // Determine the NodeChain we are publishing to \n            let updateNodeWithNodeChain = false;\n            if(!nodeChainInfo){\n              // Missing, prompt for the nodechain to use \n              // - choose from an existing NodeChain in cloud Second memory \n              \n              let nodeChains = this.state.nodeChains;\n              if(!nodeChains){\n                nodeChains = await this.fetchNodeChains();\n              }\n              let chainOptions = \"Choose Chain:\\n\" + nodeChains.map((n,i)=>{\n                return [i+1,'. ', n.data.username].join('')\n              }).join(\"\\n\");\n              let chosenChain = WINDOW.prompt(chainOptions,'1');\n              if(!chosenChain){\n                this.setState({\n                  isPublishing: false\n                })\n                return false;\n              }\n              \n              nodeChainInfo = nodeChains[parseInt(chosenChain,10)-1];\n              \n              console.log('chosenChain', chosenChain, '(subtract 1)', nodeChains, nodeChainInfo);\n              \n              if(!nodeChainInfo){\n                WINDOW.alert('INVALID nodechain specified');\n                this.setState({\n                  isPublishing: false\n                })\n                return false;\n              }\n              \n              // Update the node also! \n              updateNodeWithNodeChain = true;\n              node.data.nodeChainNode = JSON.parse(JSON.stringify(nodeChainInfo));\n              \n              // remove the \"privateKey\" if exists\n              delete node.data.nodeChainNode.data.privateKey;\n              \n            }\n            \n            \n            \n            // When clicked: \n            // - may or may not be already in teaching_sources \n            // - I'm probably not the owner at first (but I want to start my own version of the Node) \n            \n            // Make sure my private key is stored for publishing to NodeChain \n            // - TODO: use my Second's private key for writing! \n            let nodeChainPrivateKey = universe.localStorage.getItem('nodechain_private_key') || '';\n            if(!nodeChainPrivateKey.length){\n              nodeChainPrivateKey = WINDOW.prompt('Private Key for Publishing (base64)','');\n              if(!nodeChainPrivateKey){\n                return false;\n              }\n              nodeChainPrivateKey = atob(nodeChainPrivateKey);\n              universe.localStorage.setItem('nodechain_private_key', nodeChainPrivateKey);\n            }\n            \n            let publishKey = new universe.rsa(nodeChainPrivateKey);\n            let publishPublicKey = publishKey.exportKey('public');\n            \n            console.log('My Publishing PublicKey:', publishPublicKey);\n            \n            // Get code node for key + publicKey \n            // - will get latest version \n            // - we will increment that version (assuming an integer-as-string for version) \n            \n            let latestCodeNode = this.state.latestNode;\n            // universe.lodash.sortBy(this.state.chainNodes,n=>{\n            //   return parseInt(n.version, 10)\n            // });\n            // if(!latestCodeNode.length){\n            //   latestCodeNode = null;\n            // }\n            // if(latestCodeNode && latestCodeNode.length){\n            //   latestCodeNode = latestCodeNode[latestCodeNode.length - 1];\n            // }\n            \n            \n            if(publishPublicKey == node.data.author){\n              // I'm updating my own node \n              // - update version number \n              console.log('Updating my own node');\n              \n              if(!latestCodeNode){\n                console.log('trying to update without existing');\n                WINDOW.alert('trying to update without existing on chain (error fetching?)');\n                \n                this.setState({\n                  isPublishing: false\n                })\n                return false;\n              }\n              \n              version = ((parseInt(latestCodeNode.version, 10) || 0) + 1).toString()\n              \n              console.log('New Version:', version);\n              \n            \n              // publish code to NodeChain \n              console.log('Publish code node to NodeChain');\n              let newChainNode = await universe.publishToNodeChain({\n                apiAddress: nodeChainInfo.data.apiAddress,\n                nodeInputStr: JSON.stringify({\n                  type: node.type,\n                  data: {\n                    key: ref,\n                    internalId: node.data.internalId,\n                    code: node.data.code,\n                    note: node.data.note,\n                    version\n                  }\n                }),\n                privateKey: nodeChainPrivateKey,\n                chainPubKey: nodeChainInfo.data.pubKey,\n                // chainPubKey: atob('LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlHZk1BMEdDU3FHU0liM0RRRUJBUVVBQTRHTkFEQ0JpUUtCZ1FDQk5uRkMya1Z5bllDZGg0NDFOeEZxQjJUVgpLVFlaUFBaZ01mU2RxcmRDT0FGcTNnMFcyVG12U3pTMnFZNDNEVjgwdHB6ekVOaTRibk9rT1VGVmw5WGk1NTNDCisraGRucWcrcEFHYlQ5UDNDcjdyNkNOMVpOQlB4OEpYbnlXTmZ4ek5oaStyQ21hMUVwWmFvUkhiVnhUWDE3MFYKVzJxeW95Wkk4cUc5cnNxQjdRSURBUUFCCi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLQ=='),\n                ref,\n                version,\n                nonce: universe.uuidv4()\n              });\n              \n              // Update the \"local\" (remote Second) node as well \n              // - updated version, author, etc. \n      \n              console.log('New Chain Node (code update):', newChainNode);\n              \n              if(newChainNode.error){\n                return WINDOW.alert('Error publishing');\n              }\n              if(!newChainNode.node){\n                return WINDOW.alert('Error publishing2');\n              }\n              \n              node.data.version = version;\n              // node.data.author = author; // already correct\n              \n              // update on remote second\n              let nodeToSave = {\n                _id: node._id,\n                data: node.data, // type should be correct! ,\n                updatedAt: (new Date()).getTime()\n              }\n              \n              console.log('Updating Node:', nodeToSave);\n              await this.makeSaveRequest(nodeToSave);\n              \n            \n              // update whole Node \n              // - easier than updating individual parts for now\n              this.refetchNode();\n              \n              \n            } else {\n              \n              // publishPublickKey != node.data.author\n              \n              // I'm creating my own code-node-version from someone else's node (or a blank node) \n              // - I need to update the publicKey to be my own \n              //  - add the \"branched at\" information in case I want to go backwards (TODO) \n              console.log('Creating new code node or updating someone elses code node');\n              \n              if(latestCodeNode){\n                // found existing ref+author match (i'm actualy forking, not creating an entirely new one) \n                WINDOW.alert('Unable to fork yet');\n                \n                this.setState({\n                  isPublishing: false\n                })\n                return false;\n                \n              } else {\n                // not able to find any existing code with matching reference and author \n                // - aka \"totally new\" \n                \n                console.log('totally new code node (no ref+author)');\n                \n                author = publishPublicKey;\n                version = '1';\n                \n                if(!WINDOW.confirm('Create new Node? (no existing ref+author found)')){\n                  this.setState({\n                    isPublishing: false\n                  })\n                  return false;\n                }\n                \n                // publish code to NodeChain \n                console.log('Publish code node to NodeChain');\n                let newChainNode = await universe.publishToNodeChain({\n                  apiAddress: nodeChainInfo.data.apiAddress,\n                  nodeInputStr: JSON.stringify({\n                    type: node.type,\n                    data: {\n                      key: ref,\n                      internalId: node.data.internalId,\n                      code: node.data.code,\n                      note: node.data.note,\n                      version\n                    }\n                  }),\n                  privateKey: nodeChainPrivateKey,\n                  chainPubKey: nodeChainInfo.data.pubKey,\n                  // chainPubKey: atob('LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlHZk1BMEdDU3FHU0liM0RRRUJBUVVBQTRHTkFEQ0JpUUtCZ1FDQk5uRkMya1Z5bllDZGg0NDFOeEZxQjJUVgpLVFlaUFBaZ01mU2RxcmRDT0FGcTNnMFcyVG12U3pTMnFZNDNEVjgwdHB6ekVOaTRibk9rT1VGVmw5WGk1NTNDCisraGRucWcrcEFHYlQ5UDNDcjdyNkNOMVpOQlB4OEpYbnlXTmZ4ek5oaStyQ21hMUVwWmFvUkhiVnhUWDE3MFYKVzJxeW95Wkk4cUc5cnNxQjdRSURBUUFCCi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLQ=='),\n                  ref,\n                  version,\n                  nonce: universe.uuidv4()\n                });\n                \n                // Update the \"local\" (remote Second) node as well \n                // - updated version, author, etc. \n        \n                console.log('New Chain Node:', newChainNode);\n                \n                if(newChainNode.error){\n                  return WINDOW.alert('Error publishing');\n                }\n                if(!newChainNode.node){\n                  return WINDOW.alert('Error publishing2');\n                }\n                \n                node.data.version = version;\n                node.data.author = author;\n                \n                // update on server\n                let nodeToSave = {\n                  _id: node._id,\n                  data: node.data, // type should be correct! ,\n                  updatedAt: (new Date()).getTime()\n                }\n                \n                console.log('Updating Node:', nodeToSave);\n                await this.makeSaveRequest(nodeToSave);\n                \n              }\n            \n              // update whole Node \n              // - easier than updating individual parts for now\n              this.refetchNode();\n            \n              this.setState({\n                isPublishing: false\n              })\n              \n            }\n            \n            \n            \n            // Got a code node from remote? \n            // - if yes, update version automatically and approve \n            // - if no, create a new one \n            \n            \n            \n            // Update the local CodeNode (with new version, etc.) \n            \n            \n            // Will create a new one if necessary \n            // - only available if node's Parent is folder:teaching_sources\n            \n            \n          });\n      \n        }\n        \n        @autobind\n        fetchNodeChains(){\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            try {\n              \n              this.setState({\n                // fetchingRemote: true\n              })\n              \n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main'\n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode, \n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      if(inputNode.nodeId){\n                                        return false;\n                                      }\n                                      \n                                      if(inputNode.type.split(':')[0] != 'node_chain_info'){\n                                        return null;\n                                      }\n                                      \n                                      // if(inputNode.data.learn != 'browser_developer'){\n                                      //   return null;\n                                      // }\n                                      \n                                      // // strip childnodes\n                                      // // delete inputNode.nodes; \n                                      // // delete inputNode.parent;\n                                      // delete inputNode.data;\n              \n                                      return inputNode;\n                                      \n                                    })()`\n                                  }\n                                },\n                                \n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[0].data;\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                nodeChains: nodes,\n                // fetchingRemote: false\n              })\n              \n              return resolve(nodes);\n              \n              \n            } catch(err){\n              console.error('Failed getting node_chain_info nodes');\n              \n              this.setState({\n                // fetchingRemote: false\n              })\n              \n              \n              return reject();\n              \n            }\n            \n          });\n          \n        }\n      \n        @autobind\n        handleDelete(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let node = JSON.parse(JSON.stringify(this.props.node));\n      \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Delete for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n      \n            this.setState({\n              saving: true\n            });\n            \n            node.active = false;\n            let deleted = await this.makeSaveRequest({\n              _id: node._id,\n              active: false\n            }, true);\n            \n            const deleteChildNodes = (childNodes) => {\n              return new Promise(async (resolve, reject)=>{\n                \n                for(let tmpNode of childNodes){\n      \n                  // let deletedChildNode = await this.makeDelete(tmpNode);\n                  tmpNode.active = false;\n                  let deletedChildNode = await this.makeSaveRequest({\n                    _id: tmpNode._id,\n                    active: false\n                  }, true);\n      \n                  if(tmpNode.nodes && tmpNode.nodes.length){\n                    await deleteChildNodes(tmpNode.nodes);\n                  }\n                }\n                resolve();\n      \n              });\n            }\n      \n            if(node.nodes){\n              await deleteChildNodes(node.nodes);\n            }\n      \n            this.setState({\n              saving: false\n            });\n        \n            console.log('Done Deleting (and children)');\n          \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n            this.props.setState({\n              editingNode: null\n            })\n            // window.location = '/node';\n      \n          });\n      \n        }\n      \n        @autobind\n        handleDeleteChildren(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let node = JSON.parse(JSON.stringify(this.props.node));\n      \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt(`Delete ${node.nodes.length} child nodes for sure?`,'y');\n            if(confirmed != 'y'){\n              return false;\n            }\n      \n            this.setState({\n              saving: true\n            });\n            \n            // node.active = false;\n            // let deleted = await this.makeSaveRequest({\n            //   _id: node._id,\n            //   active: false\n            // }, true);\n            \n            const deleteChildNodes = (childNodes) => {\n              return new Promise(async (resolve, reject)=>{\n                \n                for(let tmpNode of childNodes){\n      \n                  // let deletedChildNode = await this.makeDelete(tmpNode);\n                  tmpNode.active = false;\n                  let deletedChildNode = await this.makeSaveRequest({\n                    _id: tmpNode._id,\n                    active: false\n                  }, true);\n      \n                  if(tmpNode.nodes && tmpNode.nodes.length){\n                    await deleteChildNodes(tmpNode.nodes);\n                  }\n                }\n                resolve();\n      \n              });\n            }\n      \n            if(node.nodes){\n              await deleteChildNodes(node.nodes);\n            }\n      \n            this.setState({\n              saving: false\n            });\n        \n            console.log('Done Deleting (and children)');\n          \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n      \n          });\n      \n        }\n        \n        @autobind\n        makeSaveRequest(nodeToSave, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            this.setState({\n              saving: true\n            })\n            \n            // Make request to save Node on remote \n            try {\n              \n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main'\n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'update_node:0.0.1:local:392821982y3',\n                            dataForAction: {\n                              type: 'node:0.0.1:local:123445',\n                              data: nodeToSave\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('Update response:', response);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              this.setState({\n                saving: false\n              })\n              \n              return resolve({\n                type: 'node:...',\n                data: response.data.actionResponses[0]\n              });\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              alert('Failed');\n              \n              this.setState({\n                saving: false\n              })\n              \n              return reject();\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        forceNewNode(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', nodeToSave);\n                \n            // return resolve({\n            //   saveNewNode: nodeToSave\n            // });\n            \n            \n            // Make request to save Node on remote \n            try {\n              \n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main' // should keep using for browser development! \n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                            dataForAction: {\n                              type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('NewNode response:', response);\n              \n              // get the new node \n              let savedNode = response.data.actionResponses[0];\n              \n              // console.log('Saved Node:', savedNode);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              return resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n          })\n        }\n      \n        @autobind\n        handleKeyDown(e){\n          if(this.aceRef && this.aceRef.editor){\n            this.aceRef.editor.commands.addCommand({\n              name: 'save',\n              bindKey: {\n                win: 'Ctrl-S',\n                mac: 'Command-S'\n              },\n              exec: (env, args, request)=>{\n                this.saveDataUpdates();\n              }\n            });\n            \n            // overwrite Cmd-D to same as sublime \n            this.aceRef.editor.commands.addCommand({\n              name: 'selectMoreAfter2',\n              bindKey: {\n                win: 'Ctrl-D',\n                mac: 'Command-D'\n              },\n              exec: (env, args, request)=>{\n                // selectMoreAfter\n                // console.log('selectMoreAfter!');\n                this.aceRef.editor.execCommand(\"selectMoreAfter\")\n              }\n            });\n          }\n      \n        }\n        \n        @autobind\n        handleChangeMainTab(tabName){\n          \n          // using \"__ALL__\" as the \"main\" holder\n          // - otherwise assume we are editing a field \n          \n          this.setState({\n            mainTab: tabName,\n            aceHeight: 0\n          },()=>{\n            this.resizeAce();\n          })\n        }\n        \n        @autobind\n        checkForCodeUpdates(){\n          \n          // searches for updated version+ref+author \n          // - on whatever chain is specified \n          \n          return new Promise(async (resolve,reject)=>{\n            \n            // let node = this.props.node;\n            let node = this.props.editStateToObj();\n          \n            console.log('checkForCodeUpdates');\n            \n            let codeTypes = [\n              'code',\n              'react_component',\n              'preparse_code',\n              'action_code'\n            ];\n            let nodeTypeName = node.type.split(':')[0];\n            if(codeTypes.indexOf(nodeTypeName) == -1){\n              console.log('Not code, not checking for code updates (should be generic \"updates\"?)');\n              return false;\n            }\n            \n            let nested = [{\n              key: 'ref',\n              value: node.data.key\n            }];\n            if(node.data.author){\n              nested.push({\n                key: 'author',\n                value: node.data.author\n              });\n            }\n            \n            if(!node.data.nodeChainNode){\n              console.log('missing chain! (no lookup)');\n              return false;\n            }\n            \n            let chainPubKey, apiAddress;\n            \n            chainPubKey = node.data.nodeChainNode.data.pubKey;\n            apiAddress = node.data.nodeChainNode.data.apiAddress;\n            \n            let chainNodes = await universe.findOnNodeChain({\n              method: 'many',\n              nested,\n              chainPubKey, \n              apiAddress\n            });\n            \n            console.log('ChainNodes:', chainNodes);\n            \n            \n            let latestNode = universe.lodash.sortBy(chainNodes,n=>{\n              return parseInt(n.version, 10)\n            });\n            if(!latestNode.length){\n              latestNode = null;\n            }\n            if(latestNode && latestNode.length){\n              latestNode = latestNode[latestNode.length - 1];\n            }\n            \n            console.log('LatestNode:', latestNode);\n            \n            this.setState({\n              chainNodes,\n              latestNode\n            })\n            \n          });\n          \n          \n        }\n        \n        @autobind\n        async handleUpdateCode(){\n          // Update code from remote \n          // - could be extended to be generic (update xyz fields for xyz type) \n          \n          try {\n              \n            // choose node to use (latest version) \n            let nodeToUse = this.state.latestNode;\n            // universe.lodash.sortBy(this.state.chainNodes,n=>{\n            //   return parseInt(n.version, 10)\n            // })\n            // if(!nodeToUse.length){\n            //   nodeToUse = null;\n            // }\n            // if(nodeToUse && nodeToUse.length){\n            //   nodeToUse = nodeToUse[nodeToUse.length - 1];\n            // }\n            \n            // console.log('Node to use:', nodeToUse);\n            \n            let data = this.props.editStateToObj().data;\n            // let data = this.props.node.data;\n            data.code = nodeToUse.data.code; //.toString();\n            data.note = nodeToUse.data.note; // ? nodeToUse.data.note.toString() : '';\n            data.internalId = nodeToUse.data.internalId;\n            data.version = nodeToUse.version.toString();// NOT .data.version! (use version on chain) \n            if(!data.author){\n              data.author = nodeToUse.author.toString(); // should be same!\n            } else {\n              console.error('Different author!');\n            }\n            \n            // create it on the server \n            let nodeToSave = {\n              _id: this.props.node._id,\n              data,\n              updatedAt: (new Date()).getTime()\n            }\n            \n            await this.makeSaveRequest(nodeToSave);\n            \n            // update whole Node \n            // - easier than updating individual parts for now\n            this.refetchNode();\n          }catch(err){\n            console.error(err);\n          }\n          \n          \n        }\n        \n        @autobind\n        renderCodeOptions(node){\n          \n          console.log('renderCodeOptions (update this with code, react_components, etc.)'); //, node);\n          \n          let codeTypes = [\n            'code',\n            'react_component',\n            'preparse_code',\n            'action_code'\n          ];\n          let nodeTypeName = node.type.split(':')[0];\n          if(codeTypes.indexOf(nodeTypeName) == -1){\n            // dont show publish\n            return '';\n          }\n          \n          let showUpdate;\n          \n          // update to latest (has a newer version on chain) (should also be able to revert) \n          // - use when no author also, but ref/key has a value \n          // - use if no version already exists \n          let latestNode = this.state.latestNode;\n          // universe.lodash.sortBy(this.state.chainNodes,n=>{\n          //   return parseInt(n.version, 10)\n          // });\n          // if(!latestNode.length){\n          //   latestNode = null;\n          // }\n          // if(latestNode && latestNode.length){\n          //   latestNode = latestNode[latestNode.length - 1];\n          // }\n          if(latestNode && latestNode.version != node.data.version){\n            showUpdate = true;\n          }\n          \n          \n          // publish (author is equal to my stored Publish PublicKey)\n          // - increment version \n          \n          // fork+publish \n          // viewAllCode: browse all nodes entered for that ref/key (TODO) \n          \n          \n          return (\n            <div className=\"control dropdown is-hoverable\">\n              <div className=\"dropdown-trigger\">\n                                        \n                <button className={\"button is-small\" + (this.state.isPublishing ? ' is-loading':'') + (showUpdate ? ' is-warning':'') + (node.data.nodeChainNode ? '':' is-danger')}>\n                  <span>\n                    Code v{node.data.version || '0'}\n                    {\n                      node.data.nodeChainNode ? '':\n                      <span className=\"\">&nbsp;No Chain</span>\n                    }\n                  </span>\n                  <span className=\"icon is-small\">\n                    <i className=\"fa fa-angle-down\"></i>\n                  </span>\n                </button>\n              </div>\n              <div className=\"dropdown-menu\">\n                <div className=\"dropdown-content\">\n                \n                  {\n                    showUpdate ? \n                      <a className=\"dropdown-item\" onClick={this.handleUpdateCode}>\n                        Update This (v{node.data.version} -&gt; v{latestNode.version})\n                      </a>\n                    :\n                      <div className=\"dropdown-item\">\n                        <i>No updates (v{node.data.version})(v{latestNode ? latestNode.version:'null'})</i>\n                      </div>\n                  }\n                  \n                  {\n                    !node.data.nodeChainNode ? '':\n                    <a className=\"dropdown-item\" onClick={this.handleExportToNodeChain}>\n                      Publish to NodeChain\n                    </a>\n                  }\n                  \n                \n                  <a className=\"dropdown-item\" onClick={this.handleChangeNodeChainData}>\n                    Change NodeChain\n                  </a>\n                  \n                </div>\n              </div>\n            </div>\n                  \n          )\n                        \n                        \n        }\n        \n        @autobind\n        updateRemoteIdentity(){\n          return new Promise(async (resolve, reject) => {\n            \n            // make request to update remote identity \n            // - TODO: dont keep here \n              \n            let username = WINDOW.prompt('Username (case-sensitive):','');\n            if(!username){\n              return false;\n            }\n      \n            username = username.trim();\n  \n            this.setState({\n              registeringUsername: true\n            })\n            \n            // Make request to save Node on remote \n            try {\n              \n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main'\n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'register_identity:0.0.1:local:209fj2sdf23fbb',\n                            dataForAction: {\n                              type: 'string:0.0.1:local:0923jf',\n                              data: username\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('register_identity response:', response);\n              \n              this.setState({\n                registeringUsername: false\n              })\n              \n              let registerResult = response.data.actionResponses[0].data.registeredExternal.data;\n              if(!registerResult){\n                throw \"Failed, result not a boolean true\";\n              }\n                \n              universe.StellarSdk.Network.useTestNetwork();\n              let stellarServer = new universe.StellarSdk.Server('https://horizon-testnet.stellar.org');\n              let pkTargetSeed = universe.crypto.createHash('sha256').update(username).digest();\n              var pairTarget = universe.StellarSdk.Keypair.fromRawEd25519Seed(pkTargetSeed);\n              \n              WINDOW.prompt(`Registered remote Second on chain using username: ${username}\nAccount (publicKey): ${pairTarget.publicKey()}`, pairTarget.publicKey());\n\n              // cant WINDOW.open for some reason \n              let launchUrl = `https://horizon-testnet.stellar.org/accounts/${pairTarget.publicKey()}`;\n              console.log('Launch in new window', launchUrl);\n              // WINDOW.open(launchUrl,'_blank');\n              \n              return resolve({\n                type: 'node:...',\n                data: response.data.actionResponses[0]\n              });\n              \n            } catch(err){\n              console.error('Failed register_identity', err);\n              \n              WINDOW.alert('Failed');\n              \n                \n              this.setState({\n                registeringUsername: false\n              })\n              \n              return reject();\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        checkIdentity(){\n          return new Promise(async(resolve,reject)=>{\n              \n            // lookup a username (if it exists) \n            // - get the IPFS hash for the user too (and parse the Identity) \n              \n            let username = WINDOW.prompt('Username (case-sensitive):','');\n            if(!username){\n              return false;\n            }\n      \n            username = username.trim();\n            \n            let subname = ''; // empty is for root \n            let usernameSplit = username.split('@');\n            if(usernameSplit.length > 1){\n              subname = usernameSplit[0];\n              username = usernameSplit[1];\n            }\n            \n            console.log('Checking Identity');\n            \n            universe.StellarSdk.Network.useTestNetwork();\n            let stellarServer = new universe.StellarSdk.Server('https://horizon-testnet.stellar.org');\n            \n            console.log('stellarServer', stellarServer);\n            \n            let pkTargetSeed = universe.crypto.createHash('sha256').update(username).digest(); //returns a buffer\n            console.log('pkTargetSeed', pkTargetSeed);\n            \n            var pairTarget = universe.StellarSdk.Keypair.fromRawEd25519Seed(pkTargetSeed);\n            \n            console.log('pairTarget', pairTarget);\n            \n            let targetAccount;\n            try {\n              targetAccount = await stellarServer.loadAccount(pairTarget.publicKey())\n              console.log('targetAccount:', targetAccount);\n            }catch(err){\n              // console.error('Failed getting targetAccount', err);\n              // this.setState({\n              //   findingHash: false,\n              //   errors: ['Unable to load Identity/Username']\n              // });\n              WINDOW.alert('Unable to load account for username');\n              return false;\n            }\n            \n                  \n            // get the current value of the Second ipfshash \n            let secondHash = await targetAccount.data({key: subname + '|second'})\n            .then(function(dataValue) {\n              let decoded = atob(dataValue.value);\n              return decoded;\n            })\n            .catch(function (err) {\n              return null;\n            })\n      \n            console.log('secondHash:', secondHash);\n            let cont = WINDOW.prompt(`\nAccountId: ${pairTarget.publicKey()}\nIdentity IPFS Hash: ${secondHash}\n\nLoad ipfshash?\n            `,'y');\n            if(cont != 'y' || !secondHash || !secondHash.length){\n              return false\n            }\n            \n            this.loadHashData(secondHash);\n            \n          })\n        }\n        \n        @autobind\n        async loadHashData(hash){\n            \n          // this.setState({\n          //   fetchingIpfs: true,\n          //   ipfsData: null\n          // });\n          // let hash = this.state.hash;\n          \n          console.log('Fetching ipfs hash:', hash);\n          \n          try {\n            let data = await universe.ipfs.files.cat(hash);\n            \n            data = JSON.stringify(JSON.parse(data),null,2);\n            \n            console.log('ipfs Data:', data);\n            \n            WINDOW.alert(`${data}`);\n            \n            \n          } catch(err){\n            WINDOW.alert('Failed fetching ipfs Hash');\n          }\n          \n          \n        }\n        \n        render(){\n          \n          // add \"fields\" to mainTab for the selected Node \n          // - also should show \"unused\" fields from schema? \n          \n          // let node = this.props.node;\n          let node = this.props.editStateToObj();\n      \n          let { value, parentValue } = this.props.editState.fields.data; // value is always a String!!!! (might not be Parseable tho!) \n    \n          let mainTabs = [\n            ['__ALL__','All']\n          ]\n      \n          let dataBeforeParse = value;\n          let isValidJSON = true;\n          let parsedData;\n          try {\n            parsedData = JSON.parse(dataBeforeParse);\n          }catch(err){\n            isValidJSON = false;\n          }\n      \n      \n          // validates?\n          let data = value;\n          let isValidDataForSchema = false;\n          let schemaValidationErrors = '';\n      \n      \n          if(this.state.schema){\n      \n            if(this.state.schema.type == 'object'){\n      \n              if(typeof data == 'string'){\n                try {\n                  data = JSON.parse(data);\n                }catch(err){\n                  // return false;\n                  data = null;\n                }\n              } else {\n                // leave as-is (assume String/Number) \n              }\n      \n            } else {\n              // use raw value\n              // data = dataBeforeParse;\n            }\n      \n            try {\n              let validate = universe.jsSchema.fromJSON(this.state.schema);\n              let validates = validate(data);\n              // console.log('validates:', validates);\n              if(validates){ \n                isValidDataForSchema = true;\n              } else {\n                schemaValidationErrors = validate.errors(data);\n              }\n              // console.log('schemaValidationErrors',schemaValidationErrors);\n            }catch(err){\n              console.error('jsSchema err:', err);\n            }\n            \n            // tabs\n            if(this.state.schema.type == 'object'\n              && isValidJSON){\n              try {\n                let objTabs = Object.keys(parsedData).map(d=>{return [d,d]});\n                mainTabs = mainTabs.concat(objTabs);\n              }catch(err){\n                \n              }\n            }\n            \n          }\n          \n          let outputVal;\n          if(this.state.mainTab != '__ALL__'){\n            // this.props.editState.fields.data.value ? this.props.editState.fields.data.value.code:''\n            try {\n              // console.log('dATAVAL',this.props.editState.fields.data.value);\n              value = JSON.parse(this.props.editState.fields.data.value)[this.state.mainTab];\n            }catch(err){\n              console.error('failed parsing value for field.', err);\n            }\n          }\n          \n          let showEditor = true,\n            showJSONRepresentation = false;\n          if(universe.lodash.isString(value)){\n            // default, expecting an editable string \n          } else {\n            showEditor = false;\n            showJSONRepresentation = true;\n          }\n          \n          return (\n            <div className=\"fill-height-or-more\">\n              <div style={{flex:'0 1 auto'}}>\n                <div style={{padding: '4px'}}>\n                  <div className=\"level-NOTANYMORE\">\n                    <div className=\"level-right-NOTANYMORE pull-right\">\n                      <div className=\"level-item-NOTANYMORE\">\n                        <div className=\"field is-grouped\">\n                        \n                          {/*\n                          <div className=\"control dropdown is-right is-hoverable\">\n                            <div className=\"dropdown-trigger\">\n                                                      \n                              <button className={\"button is-small\"}>\n                                <span>More</span>\n                                <span className=\"icon is-small\">\n                                  <i className=\"fa fa-angle-down\"></i>\n                                </span>\n                              </button>\n                            </div>\n                            <div className=\"dropdown-menu\">\n                              <div className=\"dropdown-content\">\n                              \n                                <a className=\"dropdown-item\" onClick={this.checkIdentity}>\n                                  Check Identity\n                                </a>\n                                \n                                <a className=\"dropdown-item\" onClick={this.updateRemoteIdentity}>\n                                  Register Identity\n                                </a>\n                                \n                              </div>\n                            </div>\n                          </div>\n                          */}\n                          \n                          <div className=\"control dropdown is-right is-hoverable\">\n                            <div className=\"dropdown-trigger\">\n                                                      \n                              <button className={\"button is-small is-danger\"}>\n                                <span>Delete</span>\n                                <span className=\"icon is-small\">\n                                  <i className=\"fa fa-angle-down\"></i>\n                                </span>\n                              </button>\n                            </div>\n                            <div className=\"dropdown-menu\">\n                              <div className=\"dropdown-content\">\n                              \n                                <a className=\"dropdown-item is-danger\" onClick={this.handleDelete}>\n                                  This Node\n                                </a>\n                                \n                                {\n                                  !(node.nodes && node.nodes.length) ? '':\n                                  <a className=\"dropdown-item is-danger\" onClick={this.handleDeleteChildren}>\n                                    Child Nodes\n                                  </a>\n                                }\n                                \n                              </div>\n                            </div>\n                          </div>\n                        </div>\n                        \n                      </div>\n                    </div>\n                    <div className=\"level-left-NOTANYMORE\">\n                      <div className=\"level-item-NOTANYMORE\">\n                        <h3 className=\"title is-4\">\n                          {node.type}\n                        </h3>\n                        <h3 className=\"subtitle is-6\">\n                          {node._id}\n                        </h3>\n                      </div>\n                    </div>\n                  </div>\n                </div>\n              </div>\n              <div style={{flex:'0 1 auto'}}>\n                <div style={{padding: '4px'}}>\n                  <div className=\"level\">\n                    <div className=\"level-left\">\n                      <div className=\"level-item\">\n                        <div className=\"field is-grouped\">\n                          <p className=\"control\">\n                            <a className=\"button is-small\" onClick={this.handleUpdateType}>\n                              Change Type\n                            </a>\n                          </p>\n                          <p className=\"control\">\n                            <a className=\"button is-small\" onClick={this.handleUpdateParent}>\n                              Change Parent\n                            </a>\n                          </p>\n                          <p className=\"control\">\n                            <a className=\"button is-small\" onClick={this.handleDuplicate}>\n                              Duplicate\n                            </a>\n                          </p>\n                          \n                          <div className=\"control dropdown is-hoverable\">\n                            <div className=\"dropdown-trigger\">\n                                                      \n                              <button className={\"button is-small\" + (this.state.addingChild ? ' is-loading':'')}>\n                                <span>Add Child</span>\n                                <span className=\"icon is-small\">\n                                  <i className=\"fa fa-angle-down\"></i>\n                                </span>\n                              </button>\n                            </div>\n                            <div className=\"dropdown-menu\">\n                              <div className=\"dropdown-content\">\n                              \n                                <a className=\"dropdown-item\" onClick={this.handleAddChild}>\n                                  Blank\n                                </a>\n                                \n                                <a className=\"dropdown-item\" onClick={e=>this.setState({pastable: !this.state.pastable})}>\n                                  Paste JSON\n                                </a>\n                                \n                                <a className=\"dropdown-item\" onClick={this.handleImportZip}>\n                                  Import Bundle (from GitHub)\n                                </a>\n                                \n                              </div>\n                            </div>\n                          </div>\n                          \n                          <div className=\"control dropdown is-hoverable\">\n                            <div className=\"dropdown-trigger\">\n                                                      \n                              <button className={\"button is-small\" + (this.state.fetchingParents ? ' is-loading':'')}>\n                                <span>Export</span>\n                                <span className=\"icon is-small\">\n                                  <i className=\"fa fa-angle-down\"></i>\n                                </span>\n                              </button>\n                            </div>\n                            <div className=\"dropdown-menu\">\n                              <div className=\"dropdown-content\">\n                              \n                                <a className=\"dropdown-item\" onClick={this.handleExportNode}>\n                                  Node to Clipboard\n                                </a>\n                                \n                                <a className=\"dropdown-item\" onClick={this.handleExportChildren}>\n                                  Children to ClipBoard\n                                </a>\n                                \n                                {\n                                  (!node.type || node.type.split(':')[0] != 'node_repo_on_github') ? '':\n                                  <div>\n                                    <div className=\"dropdown-divider\"></div>\n                                    <a className=\"dropdown-item\" onClick={this.handleExportChildrenToLocalStorage}>\n                                      Export App to LocalStorage\n                                    </a>\n                                    <a className=\"dropdown-item\" onClick={this.handleExportChildrenToGitHub}>\n                                      Export App to GitHub\n                                    </a>\n                                    <a className=\"dropdown-item\" onClick={this.handleClearGitHubCredentials}>\n                                      Clear GitHub Credentials\n                                    </a>\n                                  </div>\n                                }\n                                \n                                {\n                                  (!node.type || node.type.split(':')[0] != 'platform_nodes') ? '':\n                                  <div>\n                                    <div className=\"dropdown-divider\"></div>\n                                    <a className=\"dropdown-item\" onClick={this.handleExportChildrenToLocalStorage}>\n                                      Export App to LocalStorage\n                                    </a>\n                                    <a className=\"dropdown-item\" onClick={this.handleExportChildrenToGitHub}>\n                                      Export App to GitHub\n                                    </a>\n                                    <a className=\"dropdown-item\" onClick={this.handleClearGitHubCredentials}>\n                                      Clear GitHub Credentials\n                                    </a>\n                                  </div>\n                                }\n                                \n                                {\n                                  (!node.type || node.type.split(':')[0] != 'app_base') ? '':\n                                  <div>\n                                    <div className=\"dropdown-divider\"></div>\n                                    <a className=\"dropdown-item\" onClick={this.handleExportChildrenToLocalStorage}>\n                                      Export App to LocalStorage\n                                    </a>\n                                    <a className=\"dropdown-item\" onClick={this.handleExportChildrenToGitHub}>\n                                      Export App to GitHub\n                                    </a>\n                                    <a className=\"dropdown-item\" onClick={this.handleClearGitHubCredentials}>\n                                      Clear GitHub Credentials\n                                    </a>\n                                  </div>\n                                }\n                                \n                                {/*\n                                  (this.state.parentNodes || []).map(parentNode=>{\n                                    return (\n                                      <a key={parentNode._id} className=\"dropdown-item\" onClick={e=>this.handleExportChildrenToLocalStorage(parentNode.data.learn)}>\n                                        To LocalStorage: <strong>{parentNode.data ? parentNode.data.learn:'missing'}</strong>\n                                      </a>\n                                    )\n                                  })\n                                */}\n                                \n                                \n                              </div>\n                            </div>\n                          </div>\n                          \n                          {\n                            this.renderCodeOptions(node)\n                          }\n                          \n                          \n                          \n                          \n                          {\n                            !this.state.fetchingRemote ? '':\n                            <p className=\"control\">\n                              <a className={\"button is-small is-white is-loading\"}>\n                                &nbsp;\n                              </a>\n                              <a className={\"button is-small is-white\"}>\n                                Fetching remote...\n                              </a>\n                            </p>\n                          }\n                          \n                          {\n                            !this.state.isPublishing ? '':\n                            <p className=\"control\">\n                              <a className={\"button is-small is-white is-loading\"}>\n                                &nbsp;\n                              </a>\n                              <a className={\"button is-small is-white\"}>\n                                Publishing...\n                              </a>\n                            </p>\n                          }\n                          \n                          {\n                            !this.state.saving ? '':\n                            <p className=\"control\">\n                              <a className={\"button is-small is-white is-loading\"}>\n                                &nbsp;\n                              </a>\n                              <a className={\"button is-small is-white\"}>\n                                Saving...\n                              </a>\n                            </p>\n                          }\n                          \n                          {\n                            !this.state.registeringUsername ? '':\n                            <p className=\"control\">\n                              <a className={\"button is-small is-white is-loading\"}>\n                                &nbsp;\n                              </a>\n                              <a className={\"button is-small is-white\"}>\n                                Registering Username...\n                              </a>\n                            </p>\n                          }\n                          \n                          {\n                            !this.state.updatingGit ? '':\n                            <p className=\"control\">\n                              <a className={\"button is-small is-white is-loading\"}>\n                                &nbsp;\n                              </a>\n                              <a className={\"button is-small is-white\"}>\n                                Updating GitHub...({this.state.updatingGit})\n                              </a>\n                            </p>\n                          }\n                        </div>\n                      </div>\n                    </div>\n                  </div>\n                </div>\n              </div>\n              \n              {\n                !this.state.pastable ? '':\n                <div>\n                  <textarea className=\"textarea\" value={this.state.pasteText} onChange={e=>this.setState({pasteText:e.target.value})} />\n                  <button className=\"button\" onClick={this.handleAddChildPaste}>Save</button>\n                </div>\n              }\n              \n              <div style={{flex:'0 1 auto'}}>\n                <div className=\"tabs\">\n                  <ul>\n                    {\n                      mainTabs.map(tab=>(\n                        <li \n                          key={tab[0]}\n                          className={this.state.mainTab == tab[0] ? \"is-active\":''}\n                          onClick={e=>this.handleChangeMainTab(tab[0])}\n                        ><a>{tab[1]}</a></li>\n                      ))\n                    }\n                  </ul>\n                </div>\n              </div>\n              \n              <div \n                className=\"\" \n                style={{flex:'1 1 auto'}}\n                ref={r=>this.parentRef=r}\n                >\n                <div \n                  style={{height: this.state.aceHeight+'px', position: 'relative'}} \n                  >\n                  \n                  {\n                    !showEditor ? '':\n                    <AceEditor\n                      ref={r=>this.aceRef=r}\n                      mode=\"jsx\"\n                      theme=\"monokai\"\n                      value={value}\n                      onChange={v=>{\n                        if(this.state.mainTab == '__ALL__'){\n                          // if(this.state.schema.type == 'object'){\n                          //   this.props.setEditState('data', v)\n                          // } else {\n                          //   // raw\n                            this.props.setEditState('data', v)\n                          // }\n                        } else {\n                          let newObj = {};\n                          newObj[this.state.mainTab] = v;\n                          // console.log('onchangedata:', data, this.props.editState.fields.data);\n                          let newData = Object.assign({},data,newObj)\n                          this.props.setEditState('data', JSON.stringify(newData));\n                        }\n                      }}\n                      name=\"UNIQUE_ID_OF_DIV2\"\n                      editorProps={{$blockScrolling: true}}\n                      width=\"100%\"\n                      height=\"100%\"\n                      onLoad={editor=>{\n                        editor.getSession().setUseWrapMode(true);\n                      }}\n                      setOptions={{\n                        enableBasicAutocompletion: true,\n                        enableLiveAutocompletion: true,\n                        showPrintMargin: false,\n                        enableSnippets: true,\n                        behavioursEnabled: false,\n                        showLineNumbers: true,\n                        tabSize: 2\n                      }}\n                    />\n                  }\n                  \n                  {\n                    !showJSONRepresentation ? '':\n                    <pre><code>{JSON.stringify(value,null,2)}</code></pre>\n                  }\n                  \n                </div>\n              </div>\n            </div>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      \n      mycomponent = universe.withEditManager(mycomponent,{\n        editProp: 'node',\n        fields: ['type','data'],\n        fieldConvertServerOnceFunc: {\n          data: v=>{\n            return JSON.stringify(v,null,2)\n          }\n        },\n        fieldOutputFunc: {\n          data: v=>{\n            return JSON.parse(v)\n          }\n        },\n        fieldConvertServerFunc: {\n          // tmpData: v=>{\n          //   if(v){\n      \n          //   }\n          //   return v;\n          // }\n          // data: v=>{\n          //   // jsSchema\n          //   // console.log('NewServerData:', v);\n          //   if(v instanceof String){\n          //     return v;\n          //   }\n          //   return JSON.stringify(v);\n          //   // return JSON.stringify({\n          //   //   data: v // necessary to do this to retain correct types? \n          //   // },null,2)\n          // }\n        },\n        fieldCompareFunc: {\n          // uri: (prev, next)=>{\n          //   console.log('URI compare!:', prev, next);\n          //   return prev === next;\n          // }\n        }\n      });\n\n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n  \n})()",
    "note": "app store editor",
    "internalId": "MainAppEditorComponent",
    "key": "0314fe1c-5bef-43f9-a779-3e4202fc06bb",
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----"
  },
  "active": true,
  "createdAt": 1522956611048,
  "updatedAt": 1522956984753
}